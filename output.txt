############## Begin of /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/lib/main.dart ##############
///
/// File: lib/main.dart
/// Author: Adil AJDAA
/// Email: a.ajdaa@outlook.com
/// Purpose: Entry point of the Flutter application. Initializes services and sets up the app.
/// Updates: Initial setup with theme management, Mapbox access, and notification permissions.
/// Used Libraries: flutter/material.dart, flutter_dotenv/flutter_dotenv.dart, flutter_riverpod/flutter_riverpod.dart, mapbox_maps_flutter/mapbox_maps_flutter.dart
///
library;
import 'package:flutter/material.dart';
import 'package:flutter_dotenv/flutter_dotenv.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:mapbox_maps_flutter/mapbox_maps_flutter.dart';
import 'package:mobile/core/config/app_config.dart';
import 'package:mobile/core/config/app_routes.dart';
import 'package:mobile/core/config/app_theme.dart';
import 'package:mobile/core/services/notification_service.dart';
import 'package:mobile/core/services/permission_service.dart';
import 'package:mobile/core/services/storage_service.dart';
import 'package:mobile/core/utils/app_constants.dart';

void main() async {
  // Ensures that Flutter is initialized before running any app-specific code.
  WidgetsFlutterBinding.ensureInitialized();
  // Load environment variables from the .env file, allowing for configuration.
  await dotenv.load();
  // Sets the Mapbox access token using the configuration from the loaded .env file.
  MapboxOptions.setAccessToken(AppConfig.mapboxAccessToken);
  // Initializes the notification service for managing push notifications.
  await NotificationService.init();
  // Requests permission to send notifications to the user.
  await PermissionService.requestNotificationPermissions();
  // Entry point for the app, wraps the main app with ProviderScope for riverpod.
  runApp(
    const ProviderScope(
      child: MyApp(),
    ),
  );
}
// Global key for navigation, to be used outside of the widget tree.
final navigatorKey = GlobalKey<NavigatorState>();

/// `MyApp` is the root widget of the application, utilizing `ConsumerWidget` to access the Riverpod state.
class MyApp extends ConsumerWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    // Watches the themeModeProvider to dynamically update the theme based on the selected mode.
    final themeMode = ref.watch(themeModeProvider);
    // Material App is the basic app with configurations like navigator, theme, and routes.
    return MaterialApp(
      navigatorKey: navigatorKey,
      title: 'Offline Maps',
      theme: AppTheme.lightTheme,
      darkTheme: AppTheme.darkTheme,
      themeMode: themeMode,
      initialRoute: AppRoutes.map,
      routes: AppRoutes.routes,
    );
  }
}

///  Provides the current theme mode, initialized from storage, this provider can be watched for updates.
final themeModeProvider = StateProvider<ThemeMode>((ref) {
  // Fetches the storage provider to load stored data from local storage.
  final storageAsync = ref.watch(storageProvider);
  //Handles asynchronous loading of storage data to determine the stored theme mode
  final storage = storageAsync.when(
    data: (data) => data,
    error: (error, stack) {
      // Prints an error message to the console if the theme cannot be loaded from storage
      debugPrint('Error loading theme from storage: $error');
      return null;
    },
    loading: () => null,
  );
  // If the storage service is null, uses light theme by default.
  if (storage == null) {
    return ThemeMode.light;
  }
  // Gets the theme mode stored in storage.
  final themeString = storage.getString(AppConstants.themeModeKey);
  // Returns the theme based on the stored value or default light theme.
  return themeString == 'dark' ? ThemeMode.dark : ThemeMode.light;
});
############## End of /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/lib/main.dart ##############

############## Directory: /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/lib ##############

############## Directory: /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/lib/core ##############

############## Begin of /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/lib/core/config/app_config.dart ##############
///
/// File: lib/core/config/app_config.dart
/// Author: Adil AJDAA
/// Email: a.ajdaa@outlook.com
/// Purpose: Configuration settings for the application, such as API endpoints and map settings.
/// Updates: Initial configuration, added defaults for access token and API base URL.
/// Used Libraries: flutter_dotenv/flutter_dotenv.dart, flutter_riverpod/flutter_riverpod.dart
///
library;
import 'package:flutter_dotenv/flutter_dotenv.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

// AppConfig class provides static properties for application configuration
// ignore: avoid_classes_with_only_static_members
class AppConfig {
    /// Retrieves the Mapbox access token from environment variables or defaults.
  static String get mapboxAccessToken =>
      dotenv.env['MAPBOX_ACCESS_TOKEN'] ??
      'pk.eyJ1IjoiZWRzdGVpbmUiLCJhIjoiY201OGMzZWFxMXBpMTJuczJvY2s1Y2pvYiJ9.9fFMjW1mum1H9WqA2E1rQg';
  ///  Base URL for the API communication with the backend
  static const String apiBaseUrl =
      'https://w-project-u75x.onrender.com/api/v1/';
  ///  Application version number
  static const String appVersion = '1.0.0';

  /// Minimum height for image compression for the images to download for offline usage.
  static const int compressImageMinHeight = 1920;
  /// Minimum width for image compression for the images to download for offline usage.
  static const int compressImageMinWidth = 1080;
  /// Quality for the image compression, between 0 and 100 for images to download for offline usage.
  static const int compressImageQuality = 85;

  // User Paths: These are API paths related to user operations.
    /// User base path for user operations
  static String get userPath => '${apiBaseUrl}users/';
    /// User path for verification
  static String get userVerify => '${userPath}verify/';
    /// User path for forgot password
  static String get userForgotPassword => '${userPath}forgot_password/';
     /// User path for reset password
  static String get userResetPassword => '${userPath}reset_password/';

  // Locations Paths: These are API paths related to location operations.
    /// Location base path for locations
  static String get locationsPath =>
      '${apiBaseUrl}locations/?page=1&page_size=150';
  /// Location path for nearby locations
  static String get locationsNearbyPath => '${apiBaseUrl}nearby/';
  /// Location path for statistics
  static String get locationsStatistics => '${apiBaseUrl}statistics/';

  /// Default map settings for initial map view.
  static Map<String, double> defaultMapSettings = {
    'initialLatitude': 0.0,
    'initialLongitude': 0.0,
    'initialZoom': 2.0,
    'minZoom': 0.0,
    'maxZoom': 22.0,
  };

   /// Default settings for offline map downloads
  static Map<String, int> offlineMapSettings = {
    'maxTiles': 10000,
    'minZoom': 10,
    'maxZoom': 15,
  };
}

/// ConfigProvider to provide the AppConfig as a provider instance.
final configProvider = Provider<AppConfig>((ref) => AppConfig());
############## End of /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/lib/core/config/app_config.dart ##############

############## Begin of /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/lib/core/config/app_routes.dart ##############
///
/// File: lib/core/config/app_config.dart
/// Author: Adil AJDAA
/// Email: a.ajdaa@outlook.com
/// Purpose: Configuration settings for the application, such as API endpoints and map settings.
/// Updates: Initial configuration, added defaults for access token and API base URL.
/// Used Libraries: flutter_dotenv/flutter_dotenv.dart, flutter_riverpod/flutter_riverpod.dart
///
library;

import 'package:flutter/material.dart';
import 'package:mobile/features/map/map_screen.dart';
import 'package:mobile/features/offline_map/offline_map_screen.dart';
import 'package:mobile/features/settings/settings_screen.dart';

//  AppRoutes class provides static properties for managing navigation routes within the app.
// ignore: avoid_classes_with_only_static_members
class AppRoutes {
    /// Route for the map screen.
  static const String map = '/map';
     /// Route for the settings screen.
  static const String settings = '/settings';
    /// Route for the offline map screen.
  static const String offlineMap = '/offline_map';

    /// Defines the routes, linking route names to their corresponding screen widgets.
  static Map<String, WidgetBuilder> routes = {
    map: (context) => const MapScreen(),
    settings: (context) => const SettingsScreen(),
    offlineMap: (context) => const OfflineMapScreen(),
  };
}
############## End of /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/lib/core/config/app_routes.dart ##############

############## Begin of /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/lib/core/config/app_theme.dart ##############
///
/// File: lib/core/config/app_theme.dart
/// Author: Adil AJDAA
/// Email: a.ajdaa@outlook.com
/// Purpose: Defines the theme settings for the Flutter application.
/// Updates: Initial setup of light and dark themes with primary, secondary, and error colors.
/// Used Libraries: flutter/material.dart
///
library;
import 'package:flutter/material.dart';

// AppTheme class provides static properties for application's theme configurations
// ignore: avoid_classes_with_only_static_members
class AppTheme {
  /// Primary color for the theme
  static const Color primaryColor = Color(0xff6200ee);
  /// Secondary color for the theme
  static const Color secondaryColor = Color(0xff03dac6);
  /// Error color for the theme
  static const Color errorColor = Color(0xffb00020);

  /// Light theme settings for the app
  static ThemeData lightTheme = ThemeData(
    colorScheme: ColorScheme.fromSeed(seedColor: primaryColor).copyWith(
      onPrimary: Colors.white,
      surface: Colors.grey[100],
      onSurface: Colors.black,
      primaryContainer: primaryColor,
      onPrimaryContainer: Colors.white,
      secondaryContainer: secondaryColor,
      onSecondaryContainer: Colors.black,
      error: errorColor,
      onError: Colors.white,
    ),
    appBarTheme: const AppBarTheme(
      backgroundColor: primaryColor, // This will color the app bar
      foregroundColor: Colors.white, // This will color the title and icons
    ),
    useMaterial3: true,
  );

    /// Dark theme settings for the app
  static ThemeData darkTheme = ThemeData(
    colorScheme: ColorScheme.fromSeed(seedColor: primaryColor).copyWith(
      brightness: Brightness.dark,
      onPrimary: Colors.black,
      surface: Colors.grey[900],
      onSurface: Colors.white,
      primaryContainer: primaryColor,
      onPrimaryContainer: Colors.white,
      secondaryContainer: secondaryColor,
      onSecondaryContainer: Colors.black,
      error: errorColor,
      onError: Colors.white,
    ),
    appBarTheme: const AppBarTheme(
      backgroundColor: primaryColor, // This will color the app bar
      foregroundColor: Colors.white, // This will color the title and icons
    ),
    useMaterial3: true,
  );
}
############## End of /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/lib/core/config/app_theme.dart ##############

############## Directory: /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/lib/core/config ##############

############## Begin of /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/lib/core/utils/app_constants.dart ##############
///
/// File: lib/core/utils/app_constants.dart
/// Author: Adil AJDAA
/// Email: a.ajdaa@outlook.com
/// Purpose: Defines application constants such as default map settings, storage keys, and error messages.
/// Updates: Initial setup with constants for map, channel IDs, storage keys and error messages.
/// Used Libraries: mapbox_maps_flutter/mapbox_maps_flutter.dart
///
library;
import 'package:mapbox_maps_flutter/mapbox_maps_flutter.dart';

/// AppConstants class provides static constants used throughout the application.
class AppConstants {
  // Map Constants
   /// Default longitude value
  static const double defaultLongitude = -7.6351861;
    /// Default latitude value
  static const double defaultLatitude = 33.5724805;

    /// Default zoom value for the map
  static const double defaultZoom = 14;
   /// Minimum zoom value for the map
  static const int minZoom = 0;
    /// Maximum zoom value for the map
  static const int maxZoom = 22;

  // Notification Channel Constants
    /// ID of the notification channel
  static const String channelId = 'channelId';
     /// Name of the notification channel
  static const String channelName = 'channelName';
    /// Description of the notification channel
  static const String channelDescription = 'channelDescription';
  // Storage Keys
   /// Storage key for markers
  static const String markersKey = 'markers';
   /// Storage key for theme mode
  static const String themeModeKey = 'theme_mode';

  // Error Messages
    /// Error message for network issues
  static const String networkError = 'Network error occurred';
    /// Error message for when the user is offline
  static const String offlineError = 'You are currently offline';
    /// Error message for download issues
  static const String downloadError = 'Failed to download region';

    /// Error message when markers fail to load
  static const String unableToLoadMarkersError = 'Unable to load markers';
    /// Error message when download operation fails
  static const String downloadFailedError = 'Download failed: ';
   /// Error message when failed to download a region
  static const String failedToDownloadRegion = 'Failed to download region: ';
  // static const int defaultMaxZoomLevel = 13;
  // static const int defaultMinZoomLevel = 10;
   /// Mapbox streets style url
  static const String mapboxStreets = MapboxStyles.MAPBOX_STREETS;
}

/// enum to represent the download status
enum DownloadStatus {
  /// idle
  idle,
  /// downloading
  downloading,
  /// completed
  completed,
}
############## End of /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/lib/core/utils/app_constants.dart ##############

############## Begin of /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/lib/core/utils/app_utils.dart ##############
///
/// File: lib/core/utils/app_utils.dart
/// Author: Adil AJDAA
/// Email: a.ajdaa@outlook.com
/// Purpose: Provides utility functions for the application, such as formatting file sizes and handling state errors.
/// Updates: Initial setup with file size formatting and generic error handling.
/// Used Libraries: flutter/foundation.dart, flutter/material.dart, flutter_riverpod/flutter_riverpod.dart, mobile/core/utils/app_constants.dart, mobile/core/utils/context_provider.dart, mobile/core/utils/error_manager.dart
///
library;
import 'dart:math';

import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:mobile/core/utils/app_constants.dart';
import 'package:mobile/core/utils/context_provider.dart';
import 'package:mobile/core/utils/error_manager.dart';

// AppUtils class provides static utility functions for the application
// ignore: avoid_classes_with_only_static_members
class AppUtils {
  /// Formats a file size in bytes into human-readable format (B, KB, MB, GB, TB).
  static String formatFileSize(int bytes) {
    // Checks if size is zero, returns '0 B'.
    if (bytes <= 0) {
      return '0 B';
    }
     // Defines suffixes for file sizes.
    const suffixes = ['B', 'KB', 'MB', 'GB', 'TB'];
    // Calculates the index of the suffix needed for appropriate formatting.
    final i = (log(bytes) / log(1024)).floor();
    // Formats the file size to a readable string with appropriate suffix.
    return '${(bytes / pow(1024, i)).toStringAsFixed(2)} ${suffixes[i]}';
  }
// lib/core/utils/app_utils.dart

  /// Generic error handling for state notifiers. It updates state, prints the error, and shows a SnackBar.
  static void handleStateError<T extends StateNotifier<S>, S, R extends Ref>(
    T notifier,
    R ref,
    S state,
    dynamic error,
    String errorMessage,
  ) {
      // Checks if the notifier is still mounted to prevent errors on disposed widgets.
    if (!notifier.mounted) {
      return;
    }
    // Creates a new state with the error message and download status.
    final newState = (state as dynamic).copyWith(
      downloadStatus: DownloadStatus.idle,
      error: errorMessage,
    );

    //Updates the state with the new state.
    notifier.state = newState;
     // Prints the error to the console in debug mode.
    if (kDebugMode) {
      print('Error: $error');
    }
    // Retrieves the current build context from the context provider
    final context = ref.read(contextProvider);
     //Checks if the context is valid for showing the snackbar.
    if (context != null) {
     //Shows a snackbar message to the user with error message
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text(errorMessage)),
      );
    }
    // Sets the error in the error provider
    ref.read(errorProvider.notifier).setError(errorMessage);
  }
}
############## End of /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/lib/core/utils/app_utils.dart ##############

############## Begin of /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/lib/core/utils/context_provider.dart ##############
///
/// File: lib/core/utils/context_provider.dart
/// Author: Adil AJDAA
/// Email: a.ajdaa@outlook.com
/// Purpose: Provides a way to access the current BuildContext throughout the application.
/// Updates: Initial setup, used to get current BuildContext for operations.
/// Used Libraries: flutter/material.dart, flutter_riverpod/flutter_riverpod.dart
///
library;
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

/// Context provider allows other parts of application to access build context.
final contextProvider = StateProvider<BuildContext?>((ref) => null);
############## End of /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/lib/core/utils/context_provider.dart ##############

############## Begin of /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/lib/core/utils/map_utils.dart ##############
///
/// File: lib/core/utils/map_utils.dart
/// Author: Adil AJDAA
/// Email: a.ajdaa@outlook.com
/// Purpose: Provides utility functions related to map operations, such as checking if a point is in bounds and calculating distances.
/// Updates: Initial setup with functions to check point in bounds and calculate distance.
/// Used Libraries: mapbox_maps_flutter/mapbox_maps_flutter.dart
///
library;
import 'dart:math' as math;
import 'package:mapbox_maps_flutter/mapbox_maps_flutter.dart';

// MapUtils class provides static utility functions for map-related operations
// ignore: avoid_classes_with_only_static_members
class MapUtils {
    /// Checks if a given point is within the specified coordinate bounds.
  static bool isPointInBounds(Point point, CoordinateBounds bounds) {
    // Get the coordinates of the point
    final pointCoords = point.coordinates;
     // Get the coordinates of the southwest bound
    final southwestCoords = bounds.southwest.coordinates;
     // Get the coordinates of the northeast bound
    final northeastCoords = bounds.northeast.coordinates;

    // Checks if the point is within the bounds
    return pointCoords[1]! >= southwestCoords[1]! &&
        pointCoords[1]! <= northeastCoords[1]! &&
        pointCoords[0]! >= southwestCoords[0]! &&
        pointCoords[0]! <= northeastCoords[0]!;
  }

    /// Calculates the distance in meters between two points using the Haversine formula.
  static double calculateDistance(Point point1, Point point2) {
    const double earthRadius = 6371000; // meters
     // Get the coordinates of the first point
    final coords1 = point1.coordinates;
     // Get the coordinates of the second point
    final coords2 = point2.coordinates;

    final lat1 = coords1[1]! * math.pi / 180; // Convert latitude of point1 to radians
    final lat2 = coords2[1]! * math.pi / 180;// Convert latitude of point2 to radians
    final lon1 = coords1[0]! * math.pi / 180;// Convert longitude of point1 to radians
    final lon2 = coords2[0]! * math.pi / 180;// Convert longitude of point2 to radians

    final dLat = lat2 - lat1; // Calculate the difference in latitude
    final dLon = lon2 - lon1;// Calculate the difference in longitude

     // Haversine formula to calculate the distance between two points.
    final a = math.sin(dLat / 2) * math.sin(dLat / 2) +
        math.cos(lat1) *
            math.cos(lat2) *
            math.sin(dLon / 2) *
            math.sin(dLon / 2);

    final c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a));
     // Returns the distance in meters
    return earthRadius * c;
  }
}
############## End of /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/lib/core/utils/map_utils.dart ##############

############## Begin of /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/lib/core/utils/error_manager.dart ##############
///
/// File: lib/core/utils/error_manager.dart
/// Author: Adil AJDAA
/// Email: a.ajdaa@outlook.com
/// Purpose: Provides a state management solution for handling errors in the application.
/// Updates: Initial setup for error state and notifier.
/// Used Libraries: flutter_riverpod/flutter_riverpod.dart
///
library;
import 'package:flutter_riverpod/flutter_riverpod.dart';

/// Represents the state of an error in the application.
class ErrorState {
  ErrorState({this.message});
  /// Message of the error.
  final String? message;

  ///  Creates a copy of the ErrorState with an optional updated message.
  ErrorState copyWith({String? message}) =>
      ErrorState(message: message ?? this.message);
}

/// Manages the state of errors, providing methods to set and clear errors.
class ErrorNotifier extends StateNotifier<ErrorState> {
  ErrorNotifier() : super(ErrorState());

  set mapState(ErrorState newState) {
    state = newState;
  }

  ErrorState get mapState => state;

  // void updateState(ErrorState newState) {
  //   state = newState;
  // }
  /// Sets a new error message.
  void setError(String message) {
    // updateState(state.copyWith(message: message));
    state.copyWith(message: message);
  }

    /// Clears the current error message.
  void clearError() {
    // updateState(state.copyWith());
    state.copyWith();
  }
}

/// Provider for the ErrorNotifier to manage error state throughout the app.
final errorProvider = StateNotifierProvider<ErrorNotifier, ErrorState>(
  (ref) => ErrorNotifier(),
);
############## End of /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/lib/core/utils/error_manager.dart ##############

############## Directory: /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/lib/core/utils ##############

############## Begin of /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/lib/core/performance/app_resource_optimizer.dart ##############
///
/// File: lib/core/performance/app_resource_optimizer.dart
/// Author: Adil AJDAA
/// Email: a.ajdaa@outlook.com
/// Purpose: Provides utility functions for optimizing application resources, such as compressing images and clearing temporary files.
/// Updates: Initial setup with image compression and temporary file cleaning.
/// Used Libraries: dart/io.dart, flutter/foundation.dart, flutter_image_compress/flutter_image_compress.dart, mobile/core/config/app_config.dart, path_provider/path_provider.dart
///
library;
import 'dart:io';

import 'package:flutter/foundation.dart';
import 'package:flutter_image_compress/flutter_image_compress.dart';
import 'package:mobile/core/config/app_config.dart';
import 'package:path_provider/path_provider.dart';

// AppResourceOptimizer class provides static utility functions for app resources optimization
// ignore: avoid_classes_with_only_static_members
class AppResourceOptimizer {
  /// Compresses an image represented as a Uint8List, using compute to execute on a separate thread.
  static Future<Uint8List?> compressImage(Uint8List list) async =>
      compute(_compressImage, list);

  ///  Internal function to perform the image compression.
  static Future<Uint8List?> _compressImage(Uint8List list) async {
     //Checks if the image is not empty before compressing.
    if (list.isEmpty) {
      return null;
    }
     // Compress the image with configured height, width, and quality.
    final compressedImage = await FlutterImageCompress.compressWithList(
      list,
      minHeight: AppConfig.compressImageMinHeight,
      minWidth: AppConfig.compressImageMinWidth,
      quality: AppConfig.compressImageQuality,
    );
    // Prints the compressed image size to the console in debug mode.
    if (kDebugMode) {
      print('Compressed image size: ${compressedImage.length} bytes');
    }
    // Returns the compressed image
    return compressedImage;
  }

    /// Clears temporary files from the application's temporary directory.
  static Future<void> clearTempFiles() async {
      // Get the temporary directory.
    final tempDir = await getTemporaryDirectory();
    //  Gets all files inside the temp directory.
    final files = tempDir.listSync();
     // Loops over the files
    for (final file in files) {
      if (file is File) {
        try {
          // Tries to delete the current file.
          await file.delete();
         // Prints an error if the file cannot be deleted
        } on Exception catch (e) {
          if (kDebugMode) {
            print('Error deleting file: $e');
          }
        }
      }
    }
  }
}
############## End of /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/lib/core/performance/app_resource_optimizer.dart ##############

############## Begin of /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/lib/core/performance/performance_monitor.dart ##############
///
/// File: lib/core/performance/performance_monitor.dart
/// Author: Adil AJDAA
/// Email: a.ajdaa@outlook.com
/// Purpose: Provides functionalities for monitoring the performance of the Flutter application, such as frame timings and widget rebuilds.
/// Updates: Initial setup with start and stop monitoring functionalities and frame timings.
/// Used Libraries: flutter/foundation.dart, flutter/material.dart, flutter/rendering.dart, flutter/scheduler.dart
///
library;
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:flutter/rendering.dart';
import 'package:flutter/scheduler.dart';

//  PerformanceMonitor class provides static functions for monitoring application performance.
// ignore: avoid_classes_with_only_static_members
class PerformanceMonitor {
    /// Boolean indicating if the monitoring is active.
  static bool isMonitoring = false;

    /// Starts the performance monitoring if in debug mode, prints rebuilds, layouts, and frame timing.
  static void startMonitoring() {
    if (kDebugMode && !isMonitoring) {
      isMonitoring = true;
      debugPrintRebuildDirtyWidgets = true;
      debugPrintLayouts = true;
      debugPrintBeginFrameBanner = true;
      debugPrintEndFrameBanner = true;

       // Adds a callback for frame timings.
      WidgetsBinding.instance.addTimingsCallback(_onFrameTimings);
    }
  }

   /// Handles frame timings, logging details about build and raster durations.
  static void _onFrameTimings(List<FrameTiming> timings) {
    // Loops over the frame timings.
    for (final timing in timings) {
      final buildTime = timing.buildDuration.inMilliseconds;
      final rasterTime = timing.rasterDuration.inMilliseconds;

      // Logs details for dropped frames if the time is over the recommended 16 ms.
      if (buildTime > 16 || rasterTime > 16) {
         // Gathers details about which widgets were rebuilt
        final buildDetails = _getBuildDetails();
        debugPrint(
          'Frame drop detected - Build: ${buildTime}ms, Raster: ${rasterTime}ms, Rebuilt Widgets: $buildDetails',
        );
      }
       // Example timer for each method.
      _methodTimer(
        'Raster',
        () {
           // Example of a raster method being timed.
          // You can replace this with any raster method you want to measure
          // const Color color = Colors.red; // Example action
          // final paint = Paint()..color = color;
          // if (kDebugMode) {
          // print('doing some raster work');
          // }
        },
        rasterTime,
      );
      _methodTimer(
        'Build',
        () {
          // Example of a build method being timed.
          // You can replace this with any build method you want to measure
          // Example of a method being timed.
          // final container = Container(color: Colors.blue,); // Example Action
          // if (kDebugMode) {
          //   // print('doing some build work');
          // }
        },
        buildTime,
      );
    }
  }
   /// Measures and logs time for a method execution.
  static void _methodTimer(String methodName, Function method, int time) {
     //  Executes only in debug mode.
    if (kDebugMode) {
     // Starts a stopwatch before the method execution
      final stopwatch = Stopwatch()..start();
      // method();
      // stopwatch.stop();
       //Prints the method time.
      debugPrint(
        '$methodName time: ${time}ms, actual method time: ${stopwatch.elapsedMilliseconds}ms',
      );
    }
  }

   /// Gathers and returns a string of names of the widgets that were rebuilt.
  static String _getBuildDetails() {
    final rebuiltWidgets = <String>[];
    // Only do this in debug
    if (kDebugMode) {
      WidgetsBinding.instance.rootElement?.visitChildren((element) {
        if (element is RenderObjectElement) {
          final renderObject = element.renderObject;
          if (renderObject.debugNeedsPaint) {
            final widgetName = element.widget.runtimeType.toString();
            rebuiltWidgets.add(widgetName);
          }
        }
      });
    }
     // Returns a string of the rebuilt widgets.
    return rebuiltWidgets.join(', ');
  }

    /// Stops the performance monitoring, resets the debug print flags, and removes the timings callback.
  static void stopMonitoring() {
    if (isMonitoring) {
      isMonitoring = false;
      debugPrintRebuildDirtyWidgets = false;
      debugPrintLayouts = false;
      debugPrintBeginFrameBanner = false;
      debugPrintEndFrameBanner = false;
       // Removes the callback for frame timings.
      WidgetsBinding.instance.removeTimingsCallback(_onFrameTimings);
    }
  }
}
############## End of /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/lib/core/performance/performance_monitor.dart ##############

############## Directory: /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/lib/core/performance ##############

############## Begin of /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/lib/core/services/permission_service.dart ##############
///
/// File: lib/core/services/permission_service.dart
/// Author: Adil AJDAA
/// Email: a.ajdaa@outlook.com
/// Purpose: Manages permission requests for the application, handling both notification and location permissions.
/// Updates: Initial setup with request methods for notification and location permissions.
/// Used Libraries: flutter/foundation.dart, geolocator/geolocator.dart, permission_handler/permission_handler.dart
///
library;
import 'package:flutter/foundation.dart';
import 'package:geolocator/geolocator.dart' as geo;
import 'package:permission_handler/permission_handler.dart';

//  PermissionService class provides static methods for requesting app permissions.
// ignore: avoid_classes_with_only_static_members
class PermissionService {
    /// Requests notification permissions from the user, handles denied or permanently denied cases.
  static Future<void> requestNotificationPermissions() async {
      // Requests the notification permission from the user.
    final status = await Permission.notification.request();
    // Prints the status of the notification permission to console in debug mode.
    if (kDebugMode) {
      print('Notification permission status: $status');
    }
     // Handles the case where notification permission is denied.
    if (status.isDenied) {
       // Prints a message to console if the permission is denied
      if (kDebugMode) {
        print('Notification permission is denied');
      }
     //Handles the case where the notification permission is permanently denied,
    } else if (status.isPermanentlyDenied) {
       // Prints a message to console when permission is denied and opening settings
      if (kDebugMode) {
        print(
          'Notification permission is permanently denied, opening app settings',
        );
      }
      // Opens the application settings to allow the user to enable the permission.
      await openAppSettings();
      //Handles the case where permission is granted by the user
    } else if (status.isGranted) {
     // Prints a message to console when permission is granted
      if (kDebugMode) {
        print('Notification permission is granted');
      }
    }
  }

   /// Requests location permissions from the user, returns the permission status.
  static Future<geo.LocationPermission> requestLocationPermissions() async {
    // Requests the location permission from the user.
    final permission = await geo.Geolocator.requestPermission();

   // Handles the case when permission is denied.
    if (permission == geo.LocationPermission.denied) {
      // Do not use the location services, and use default location.
      return geo.LocationPermission.denied;
       // Handles the case when location permission is permanently denied.
    } else if (permission == geo.LocationPermission.deniedForever) {

      // Permission has been denied, try to open the settings.
      if (kDebugMode) {
        print(
          'Location permission is permanently denied',
        );
      }
       // Opens the app settings.
      await geo.Geolocator.openAppSettings();

     // Returns the location permission status as 
      return geo.LocationPermission.deniedForever;
       // Handles the case where permission is granted by the user
    } else if (permission == geo.LocationPermission.whileInUse ||
        permission == geo.LocationPermission.always) {
      // Do use location services.
      return permission;
    }
    return geo.LocationPermission.denied;
  }
}

############## End of /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/lib/core/services/permission_service.dart ##############

############## Begin of /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/lib/core/services/notification_service.dart ##############
///
/// File: lib/core/services/notification_service.dart
/// Author: Adil AJDAA
/// Email: a.ajdaa@outlook.com
/// Purpose: Manages local notifications for the application.
/// Updates: Initial setup with initialization, showing notifications, progress notifications, and canceling notifications.
/// Used Libraries: flutter/foundation.dart, flutter_local_notifications/flutter_local_notifications.dart, mobile/core/utils/app_constants.dart
///
library;
import 'package:flutter/foundation.dart';
import 'package:flutter_local_notifications/flutter_local_notifications.dart';
import 'package:mobile/core/utils/app_constants.dart';

//  NotificationService class provides static methods for managing app notifications.
// ignore: avoid_classes_with_only_static_members
class NotificationService {
  /// Plugin for managing local notifications.
  static final FlutterLocalNotificationsPlugin flutterLocalNotificationsPlugin =
      FlutterLocalNotificationsPlugin();
    /// Action identifier for pausing a download.
  static const String downloadPauseActionId = 'download_pause_action';
    /// Action identifier for canceling a download.
  static const String downloadCancelActionId = 'download_cancel_action';

    /// Initializes the notification service by setting up platform-specific configurations.
  static Future<void> init() async {
      // Android specific notification initialization settings.
    const initializationSettingsAndroid =
        AndroidInitializationSettings('mipmap/ic_launcher');
     // Darwin (iOS and macOS) specific notification initialization settings.
    const initializationSettingsDarwin = DarwinInitializationSettings(
        // Request specific permissions, if necessary for your app
        );

     // Combines initialization settings for all platforms.
    const initializationSettings = InitializationSettings(
      android: initializationSettingsAndroid,
      iOS: initializationSettingsDarwin,
      macOS: initializationSettingsDarwin,
    );
     // Initializes the notification plugin.
    await flutterLocalNotificationsPlugin.initialize(
      initializationSettings,
      onDidReceiveNotificationResponse: _onDidReceiveNotificationResponse,
    );
  }

   /// Handles actions on notification tap
  static Future<void> _onDidReceiveNotificationResponse(
    NotificationResponse notificationResponse,
  ) async {
     // Prints the notification response to the console in debug mode.
    if (kDebugMode) {
      print('Notification response: $notificationResponse');
    }
     //Handles the case when download is paused
    if (notificationResponse.actionId == downloadPauseActionId) {
      // Pause the current action, we are not going to do anything here. The action will be handled in the MapService
       // Prints a message to the console when download is paused.
      if (kDebugMode) {
        print('Download is paused!');
      }
    } else if (notificationResponse.actionId == downloadCancelActionId) {
       // Cancel the current action, we are not going to do anything here. The action will be handled in the MapService
       // Prints a message to the console when download is canceled.
      if (kDebugMode) {
        print('Download is canceled!');
      }
    }
  }

   /// Displays a simple notification with title and body.
  static Future<void> showNotification({
    required String title,
    required String body,
    int? id,
  }) async {
    // Android specific notification details.
    const androidNotificationDetails = AndroidNotificationDetails(
      AppConstants.channelId,
      AppConstants.channelName,
      channelDescription: AppConstants.channelDescription,
      priority: Priority.max,
      importance: Importance.max,
      showWhen: false,
    );
    // Combine the platform notification details.
    const notificationDetails =
        NotificationDetails(android: androidNotificationDetails);
    // Shows the notification
    await flutterLocalNotificationsPlugin.show(
      id ?? 0,
      title,
      body,
      notificationDetails,
    );
  }

    /// Displays a progress notification with a title and a progress value.
  static Future<void> showProgressNotification({
    required String title,
    required int progress,
    int? id,
    bool indeterminate = false,
  }) async {
    // Android specific notification details
    final androidNotificationDetails = AndroidNotificationDetails(
      AppConstants.channelId,
      AppConstants.channelName,
      channelDescription: AppConstants.channelDescription,
      priority: Priority.min,
      importance: Importance.min,
      showWhen: false,
      progress: progress,
      maxProgress: 100,
      indeterminate: indeterminate,
      ongoing: true,
      actions: const <AndroidNotificationAction>[
        AndroidNotificationAction(downloadPauseActionId, 'Pause'),
        AndroidNotificationAction(downloadCancelActionId, 'Cancel'),
      ],
    );
      // Combine the platform notification details
    final notificationDetails =
        NotificationDetails(android: androidNotificationDetails);
    // Shows the progress notification
    await flutterLocalNotificationsPlugin.show(
      id ?? 1,
      title,
      '$progress%',
      notificationDetails,
    );
  }

    /// Cancels a specific notification by its ID.
  static Future<void> cancelNotification(int id) async {
     // Cancels the notification with the given id
    await flutterLocalNotificationsPlugin.cancel(id);
  }
}
############## End of /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/lib/core/services/notification_service.dart ##############

############## Begin of /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/lib/core/services/network_service.dart ##############
///
/// File: lib/core/services/network_service.dart
/// Author: Adil AJDAA
/// Email: a.ajdaa@outlook.com
/// Purpose: Handles network requests using Dio, including setting up interceptors for logging and error handling.
/// Updates: Initial setup with get, post, put, and delete methods, along with interceptors for request/response/error logging and handling.
/// Used Libraries: dio/dio.dart, flutter/foundation.dart, flutter_riverpod/flutter_riverpod.dart, mobile/core/config/app_config.dart, mobile/core/services/network_error_handler.dart
///
library;
import 'package:dio/dio.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:mobile/core/config/app_config.dart';
import 'package:mobile/core/services/network_error_handler.dart';

// Custom Exception for Network Service errors
class NetworkServiceException implements Exception {
  NetworkServiceException(this.message, this.error, [this.stackTrace]);
  final String message;
  final dynamic error;
  final StackTrace? stackTrace;

  @override
  String toString() =>
      'NetworkServiceException: $message, $error, stackTrace: $stackTrace';
}

/// NetworkService class provides methods for making network requests.
class NetworkService {
    /// Constructor for the network service setting configurations and interceptors.
  NetworkService() {
    _dio = Dio(
      BaseOptions(
        baseUrl: AppConfig.apiBaseUrl,
        connectTimeout: const Duration(seconds: 5),
        receiveTimeout: const Duration(seconds: 10),
        headers: {
          'Content-Type': 'application/json',
        },
      ),
    );
    _setupInterceptors();
  }
  /// Dio client used for making requests
  late final Dio _dio;

    /// Configures interceptors for requests, responses, and errors.
  void _setupInterceptors() {
    _dio.interceptors.add(
      InterceptorsWrapper(
        onRequest: (options, handler) {
           // Logs the request method and url in debug mode.
          if (kDebugMode) {
            print('Request: ${options.method} ${options.uri}');
          }
          return handler.next(options);
        },
        onResponse: (response, handler) {
           // Logs the response status code and url in debug mode.
          if (kDebugMode) {
            print('Response: ${response.statusCode} ${response.realUri}');
          }
          return handler.next(response);
        },
        onError: (error, handler) {
          // Logs the error message and url in debug mode.
          if (kDebugMode) {
            print('Error: ${error.message} ${error.requestOptions.uri}');
          }
           // Handles the error before passing to the next handler.
          return handler.next(_handleError(error, error.stackTrace));
        },
      ),
    );
  }

   /// Performs a GET request to the specified path.
  Future<Response> get(
    String path, {
    Map<String, dynamic>? queryParameters,
  }) async {
    try {
       // Executes the get method.
      return await _dio.get(path, queryParameters: queryParameters);
      // Handles Dio exceptions.
    } on DioException catch (e, stackTrace) {
      throw _handleError(e, stackTrace);
    }
  }

   /// Handles errors from Dio by calling the NetworkErrorHandler.
  DioException _handleError(DioException error, StackTrace? stackTrace) {
    throw NetworkErrorHandler.handle(error, stackTrace);
  }

   /// Performs a GET request with pagination to the specified path.
  Future<Response> getWithPages(
    String path, {
    int page = 1,
    int pageSize = 150,
  }) async {
    try {
       // Construct the query parameters with page and page size.
      final queryParameters = {
        'page': page.toString(),
        'page_size': pageSize.toString(),
      };
       // Executes the get method with the added query parameters.
      return await _dio.get(path, queryParameters: queryParameters);
       // Handles Dio exceptions.
    } on DioException catch (e, stackTrace) {
      throw _handleError(e, stackTrace);
    }
  }

    /// Performs a POST request to the specified path with the given data.
  Future<Response> post(String path, dynamic data) async {
    try {
      // Executes the post method.
      return await _dio.post(path, data: data);
      // Handles Dio exceptions.
    } on DioException catch (e, stackTrace) {
      throw _handleError(e, stackTrace);
    }
  }

  /// Performs a PUT request to the specified path with the given data.
  Future<Response> put(String path, dynamic data) async {
    try {
       // Executes the put method
      return await _dio.put(path, data: data);
      // Handles Dio exceptions.
    } on DioException catch (e, stackTrace) {
      throw _handleError(e, stackTrace);
    }
  }

    /// Performs a DELETE request to the specified path.
  Future<Response> delete(String path, {dynamic data}) async {
    try {
      // Executes the delete method
      return await _dio.delete(path, data: data);
      // Handles Dio exceptions.
    } on DioException catch (e, stackTrace) {
      throw _handleError(e, stackTrace);
    }
  }
}

/// Provider for the NetworkService to manage network requests throughout the app
final networkServiceProvider =
    Provider<NetworkService>((ref) => NetworkService());
############## End of /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/lib/core/services/network_service.dart ##############

############## Begin of /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/lib/core/services/tile_service.dart ##############
///
/// File: lib/core/services/tile_service.dart
/// Author: Adil AJDAA
/// Email: a.ajdaa@outlook.com
/// Purpose: Manages offline tile storage and downloads using the Mapbox Maps SDK for Flutter.
/// Updates: Initial setup with tile store initialization, tile download, and region management functions.
/// Used Libraries: dart/io.dart, flutter/foundation.dart, flutter_riverpod/flutter_riverpod.dart, mapbox_maps_flutter/mapbox_maps_flutter.dart, path_provider/path_provider.dart
///
library;
import 'dart:io';

import 'package:flutter/foundation.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:mapbox_maps_flutter/mapbox_maps_flutter.dart';
import 'package:path_provider/path_provider.dart';

// Custom exception for TileService errors
class TileServiceException implements Exception {
  TileServiceException(this.message, this.error, [this.stackTrace]);
  final String message;
  final dynamic error;
  final StackTrace? stackTrace;
  @override
  String toString() =>
      'TileServiceException: $message, $error, stackTrace: $stackTrace';
}

/// TileService class provides methods for managing offline map tiles using Mapbox SDK.
class TileService {
   /// Constructor for the tile service
  TileService();
  ///  TileStore object for tile storage operations
  TileStore? _tileStore;

    /// Initializes the tile store, creates a default tile store and sets disk quota to null.
  Future<void> initialize() async {
    try {
       // Creates the default tile store
      _tileStore = await TileStore.createDefault();
      // Sets the disk quota to null, allowing unlimited storage.
      _tileStore?.setDiskQuota(null);
      // Prints to console when tile store is successfully initialized.
      if (kDebugMode) {
        print('TileStore initialized');
      }
    } on Exception catch (e, stackTrace) {
       // Prints the error to the console if there was an issue during initialization.
      if (kDebugMode) {
        print('Error initializing TileStore: $e, StackTrace: $stackTrace');
      }
      throw TileServiceException('Error initializing TileStore', e, stackTrace);
    }
  }

    /// Downloads tiles for a specified region, zoom levels, and style URI.
  Future<void> downloadTiles(
    CoordinateBounds bounds,
    int minZoom,
    int maxZoom,
    String styleUri,
  ) async {
    // Prints a message to console when starting the download.
    if (kDebugMode) {
      print('Starting downloadTiles');
    }
    if (_tileStore == null) {
       // Initializes the tile store if it isn't already initialized
      await initialize();
    }

    try {
      // Creates a unique region ID.
      final regionId =
          '${bounds.southwest.coordinates.lng},${bounds.southwest.coordinates.lat}-${bounds.northeast.coordinates.lng},${bounds.northeast.coordinates.lat}';
      // Prints the current region id to the console.
      if (kDebugMode) {
        print('Region ID: $regionId');
      }

       // Configure tile region load options
      final tileRegionLoadOptions = TileRegionLoadOptions(
        // geometry: Point(coordinates: Position(-80.1263, 25.7845)).toJson(),
         // Setting a default geometry for the current region.
        geometry: Point(coordinates: Position(34.020882, -6.832477)).toJson(),
        // geometry: Point(coordinates: Position( -6.832477,34.020882)).toJson(),

        descriptorsOptions: [
          TilesetDescriptorOptions(
            styleURI: styleUri,
            minZoom: minZoom,
            maxZoom: maxZoom,
          ),
        ],
        acceptExpired: true,
        networkRestriction: NetworkRestriction.NONE,
      );
       // Prints a message to console when tile region is loading.
      if (kDebugMode) {
        print('Loading tile region');
      }
        // Loads the tile region, using a progress callback
      await _tileStore?.loadTileRegion(
        regionId,
        tileRegionLoadOptions,
        (progress) {
           // Prints progress to the console.
          if (kDebugMode) {
            print('TileService progress callback called');
            print('Completed resources: ${progress.completedResourceCount}');
            print('Loaded resources: ${progress.loadedResourceCount}');
            print('Errored resources: ${progress.erroredResourceCount}');
          }
        },
      );
       // Prints a message to the console when tile region is loaded.
      if (kDebugMode) {
        print('Tile region loaded');
      }
         // Get the completed tile region
      final tileRegion = await getTileRegion(regionId);
       //Prints the tile region details to the console after the download
      if (kDebugMode) {
        print(
          'Tile Region Completed Size: ${tileRegion?.completedResourceSize}',
        );
        print('Tile Region Loaded Size: ${tileRegion?.completedResourceCount}');
        print(
          'Tile Region Errored Count: ${tileRegion?.completedResourceSize}',
        );
      }
       // Catch any exception that occurs during the download
    } on Exception catch (e, stackTrace) {
      if (kDebugMode) {
        print('Error downloading tiles: $e, StackTrace: $stackTrace');
      }
       // Throws a custom exception in case of failure.
      throw TileServiceException('Error downloading tiles', e, stackTrace);
    }
  }

    /// Clears old tiles by deleting the tiles directory from the app's document directory.
  Future<void> clearOldTiles() async {
    if (_tileStore == null) {
        // Initializes the tile store if not already initialized.
      await initialize();
    }
      // Prints to console before clearing the old tiles.
    if (kDebugMode) {
      print('Clearing old tiles');
    }
    try {
      // Logic to clear old tile regions
      final dir = await getApplicationDocumentsDirectory();
      final tilesDir = Directory('${dir.path}/tiles');
      if (tilesDir.existsSync()) {
         // Delete all tiles recursively.
        tilesDir.deleteSync(recursive: true);
        // Prints to console when the old tile directory has been deleted.
        if (kDebugMode) {
          print('Old tiles directory deleted');
        }
      } else {
        // Prints to console when there are no old tiles to clear
        if (kDebugMode) {
          print('No old tiles directory found');
        }
      }
      // Catch any exception that occurs during the cleaning
    } on Exception catch (e, stackTrace) {
       // Prints the exception to console if there was an issue while clearing the old tiles.
      if (kDebugMode) {
        print('Error clearing old tiles: $e, StackTrace: $stackTrace');
      }
       // Throws a custom exception in case of failure.
      throw TileServiceException('Error clearing old tiles', e, stackTrace);
    }
  }

    /// Removes a specific tile region by its ID.
  Future<void> removeTileRegion(String regionId) async {
    if (_tileStore == null) {
         // Initializes the tile store if not already initialized.
      await initialize();
    }
    try {
       // Prints the current region id to be removed.
      if (kDebugMode) {
        print('Removing tile region: $regionId');
      }
       // Removes the tile region using it's id.
      await _tileStore?.removeRegion(regionId);
    } on Exception catch (e, stackTrace) {
       // Prints to console in case of error.
      if (kDebugMode) {
        print(
          'Error removing tile region $regionId: $e, StackTrace: $stackTrace',
        );
      }
       // Throws a custom exception in case of failure.
      throw TileServiceException(
        'Error removing tile region $regionId',
        e,
        stackTrace,
      );
    }
  }

    /// Retrieves a specific tile region by its ID.
  Future<TileRegion?> getTileRegion(String regionId) async {
    if (_tileStore == null) {
       // Initializes the tile store if not already initialized.
      await initialize();
    }
    try {
       // Gets all the tile regions.
      final regions = await _tileStore!.allTileRegions();
      // Returns the region that matches the given id or null if not exists.
      return regions.firstWhere((region) => region.id == regionId);
    } on Exception catch (e, stackTrace) {
       // Prints to console in case of error.
      if (kDebugMode) {
        print(
          'Error getting tile region $regionId: $e, StackTrace: $stackTrace',
        );
      }
       // Throws a custom exception in case of failure.
      throw TileServiceException(
        'Error getting tile region $regionId',
        e,
        stackTrace,
      );
    }
  }

    /// Retrieves all available tile regions.
  Future<List<TileRegion>> getAllTileRegions() async {
    if (_tileStore == null) {
        // Initializes the tile store if not already initialized.
      await initialize();
    }
    try {
        // Returns all the tile regions
      return await _tileStore!.allTileRegions();
       // Catch any exception that occurs while getting all the tile regions
    } on Exception catch (e, stackTrace) {
      if (kDebugMode) {
        print('Error getting all tile regions: $e, StackTrace: $stackTrace');
      }
       // Throws a custom exception in case of failure.
      throw TileServiceException(
        'Error getting all tile regions',
        e,
        stackTrace,
      );
    }
  }

   /// Checks if a region has been downloaded based on its bounds.
  Future<bool> isRegionDownloaded(CoordinateBounds bounds) async {
    if (_tileStore == null) {
      return false;
    }

    try {
      // Creates a unique region ID.
      final regionId =
          '${bounds.southwest.coordinates.lng},${bounds.southwest.coordinates.lat}-${bounds.northeast.coordinates.lng},${bounds.northeast.coordinates.lat}';
       // Prints the regionId to the console in debug mode.
      if (kDebugMode) {
        print('Checking if region is downloaded: $regionId');
      }
      // Get all regions.
      final regions = await _tileStore!.allTileRegions();
       // Checks if any region exists with the same id.
      final isDownloaded = regions.any((region) => region.id == regionId);
       // Prints whether the region is downloaded or not
      if (kDebugMode) {
        print('Region $regionId is downloaded: $isDownloaded');
      }
      return isDownloaded;
     // Catches the exception, if any happens while checking if a region is downloaded
    } on Exception catch (e) {
      if (kDebugMode) {
        print('Error checking if region is downloaded: $e');
      }
      return false; // Or handle the error appropriately
    }
  }

    /// Disposes of the tile store.
  void dispose() {
    _tileStore = null;
  }

    /// Public getter to access _tileStore.
  TileStore? get tileStore => _tileStore;
}

///  Provider for the TileService to manage tile storage and downloads.
final tileServiceProvider = Provider<TileService>((ref) => TileService());
############## End of /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/lib/core/services/tile_service.dart ##############

############## Begin of /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/lib/core/services/network_error_handler.dart ##############
///
/// File: lib/core/services/network_error_handler.dart
/// Author: Adil AJDAA
/// Email: a.ajdaa@outlook.com
/// Purpose: Handles Dio errors and provides custom error messages.
/// Updates: Initial setup to handle connection timeouts, receive timeouts, and bad responses, including a default error case.
/// Used Libraries: dio/dio.dart, flutter/foundation.dart, mobile/core/utils/app_constants.dart
///
library;
import 'package:dio/dio.dart';
import 'package:flutter/foundation.dart';
import 'package:mobile/core/utils/app_constants.dart';

// Custom exception for Network errors
// ignore: avoid_classes_with_only_static_members
class NetworkErrorHandler {
   /// Handles Dio errors, converting them into meaningful errors.
  static DioException handle(
    DioException error, [
    StackTrace? stackTrace,
  ]) {
     // Prints the error message and stack trace in debug mode
    if (kDebugMode) {
      print('Network Error: ${error.message} StackTrace: $stackTrace');
    }
     // Handle different types of Dio errors
    switch (error.type) {
     // Handles connection timeouts, receive timeouts, and connection errors, which are treated as a network error.
      case DioExceptionType.connectionTimeout:
      case DioExceptionType.receiveTimeout:
      case DioExceptionType.connectionError:
        return DioException(
          requestOptions: error.requestOptions,
          error: AppConstants.networkError,
          type: error.type,
        );
      // Handles bad responses coming from the backend
      case DioExceptionType.badResponse:
        return error;
        // Handles other types of errors that aren't in the cases above
      default:
        return DioException(
          requestOptions: error.requestOptions,
          error: 'Unexpected error occurred',
          type: error.type,
        );
    }
  }
}
############## End of /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/lib/core/services/network_error_handler.dart ##############

############## Begin of /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/lib/core/services/download_manager_service.dart ##############
///
/// File: lib/core/services/download_manager_service.dart
/// Author: Adil AJDAA
/// Email: a.ajdaa@outlook.com
/// Purpose: Manages the state of downloads.
/// Updates: Initial setup for managing download states like isDownloading and progress.
/// Used Libraries: flutter_riverpod/flutter_riverpod.dart
///
library;
// import 'package:flutter_riverpod/flutter_riverpod.dart';

// class DownloadState {
//   DownloadState({this.isDownloading = false, this.progress = 0.0, this.error});
//   final bool isDownloading;
//   final double progress;
//   final String? error;

//   DownloadState copyWith({
//     bool? isDownloading,
//     double? progress,
//     String? error,
//   }) =>
//       DownloadState(
//         isDownloading: isDownloading ?? this.isDownloading,
//         progress: progress ?? this.progress,
//         error: error ?? this.error,
//       );
// }

// class DownloadManager extends StateNotifier<DownloadState> {
//   DownloadManager() : super(DownloadState());

//   void startDownload() {
//     state = state.copyWith(isDownloading: true, progress: 0);
//   }

//   void updateProgress(double progress) {
//     state = state.copyWith(progress: progress);
//   }

//   void finishDownload() {
//     state = state.copyWith(isDownloading: false, progress: 1);
//   }

//   void setError(String error) {
//     state = state.copyWith(isDownloading: false, error: error);
//   }

//   void clearError() {
//     state = state.copyWith();
//   }
// }

// final downloadManagerProvider =
//     StateNotifierProvider<DownloadManager, DownloadState>(
//   (ref) => DownloadManager(),
// );
############## End of /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/lib/core/services/download_manager_service.dart ##############

############## Begin of /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/lib/core/services/map_service.dart ##############
///
/// File: lib/core/services/map_service.dart
/// Author: Adil AJDAA
/// Email: a.ajdaa@outlook.com
/// Purpose: Manages map-related operations such as downloading regions, removing style packs, and calculating tile counts.
/// Updates: Initial setup with functionalities for downloading regions, managing styles, and calculating tiles and size. Includes detailed error handling and logging.
/// Used Libraries: dart/async.dart, dart/math.dart, flutter/foundation.dart, flutter_riverpod/flutter_riverpod.dart, mapbox_maps_flutter/mapbox_maps_flutter.dart, mobile/core/services/notification_service.dart, mobile/core/services/tile_service.dart, mobile/core/utils/app_constants.dart, mobile/core/utils/app_utils.dart
///
library;
import 'dart:async';
import 'dart:math';

import 'package:flutter/foundation.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:mapbox_maps_flutter/mapbox_maps_flutter.dart';
import 'package:mobile/core/services/notification_service.dart';
import 'package:mobile/core/services/tile_service.dart';
import 'package:mobile/core/utils/app_constants.dart';
import 'package:mobile/core/utils/app_utils.dart';

// Custom exception for MapService errors, provides a structured way to handle errors within the service.
class MapServiceException implements Exception {
  MapServiceException(this.message, this.error, [this.stackTrace]);
  final String message;
  final dynamic error;
  final StackTrace? stackTrace;
  @override
  String toString() =>
      'MapServiceException: $message, $error, stackTrace: $stackTrace';
}

/// MapService class manages map-related operations such as tile downloads, style packs and region management.
class MapService {
  /// Constructor for the Map Service, requires an instance of `TileService`.
  MapService(this._tileManagerService);

  ///  Tile service manager for handling tile storage operations.
  final TileService _tileManagerService;

  /// Tile store object for tile storage operations
  TileStore? _tileStore;

  ///  Offline manager object to manage offline resources like style packs.
  OfflineManager? _offlineManager;

  /// Stream controller for tracking the progress of style pack loading.
  final StreamController<double> _stylePackProgress =
      StreamController<double>.broadcast();

  /// Stream that provides updates on the progress of the style pack loading, making it possible to track it from other places in the app
  Stream<double> get stylePackProgress => _stylePackProgress.stream;

  /// Stream controller for tracking the progress of tile region download.
  final StreamController<double> _tileRegionLoadProgress =
      StreamController<double>.broadcast();

  /// Stream that provides updates on the progress of the tile region loading, making it possible to track it from other places in the app.
  Stream<double> get tileRegionProgress => _tileRegionLoadProgress.stream;

  /// Initializes the offline manager, tile store, and notification services required for map operations.
  Future<void> init() async {
    try {
      // Creates a new OfflineManager instance.
      _offlineManager = await OfflineManager.create();
      // Creates a default TileStore instance and disables the disk quota
      _tileStore = await TileStore.createDefault();
      _tileStore?.setDiskQuota(null);
      // Initializes notification service.
      await NotificationService.init();
       // Catching potential exception in case of failure during the initialization of the map service
    } catch (e, stackTrace) {
      // Logging error to console when debug mode is activated
      if (kDebugMode) {
        print('Error initializing Map Service: $e, StackTrace: $stackTrace');
      }
      // Throw a custom exception for handling initialization failure
      throw MapServiceException(
        'Error initializing Map Service',
        e,
        stackTrace,
      );
    }
  }

  /// Calculates the approximate number of tiles required to cover a given region, based on the zoom levels.
  int calculateTileCount(CoordinateBounds bounds, int minZoom, int maxZoom) {
    final latDiff =
        (bounds.northeast.coordinates.lat - bounds.southwest.coordinates.lat)
            .abs();
    final lngDiff =
        (bounds.northeast.coordinates.lng - bounds.southwest.coordinates.lng)
            .abs();

    var totalTiles = 0;
    for (var z = minZoom; z <= maxZoom; z++) {
      final tilesPerLat = (latDiff * pow(2, z)).ceil();
      final tilesPerLng = (lngDiff * pow(2, z)).ceil();
      totalTiles += tilesPerLat * tilesPerLng;
    }

    return totalTiles;
  }

  /// Retrieves and formats the size of a downloaded map region, providing human-readable values
  Future<String> getRegionSize(CoordinateBounds bounds) async {
    try {
      // Creates a unique region ID using the southwest and northeast coordinates.
      final regionId =
          '${bounds.southwest.coordinates.lng},${bounds.southwest.coordinates.lat}-${bounds.northeast.coordinates.lng},${bounds.northeast.coordinates.lat}';
          // Fetches the tile region information for a given id using the tileManagerService.
      final tileRegion = await _tileManagerService.getTileRegion(regionId);
      // Returns "0 B" if no tile region is found for given id.
      if (tileRegion == null) {
        return '0 B';
      }
      // Gets the size of the completed resources.
      final sizeBytes = tileRegion.completedResourceSize;

      // Returns the formatted file size, converting from bytes to a human readable format.
      return AppUtils.formatFileSize(sizeBytes);
       // Handles any exception that occurs during the execution.
    } on Exception catch (e, stackTrace) {
      // Logs error details if an exception occurs in debug mode.
      if (kDebugMode) {
        print('Error getting region size: $e, StackTrace: $stackTrace');
      }
      // Throws a custom exception to be handled by the caller
      throw MapServiceException('Error getting region size', e, stackTrace);
    }
  }

  /// Downloads a map region with specified bounds, zoom levels and style, and notifies the user about progress and completion.
  Future<void> downloadRegion({
    required String regionName,
    required CoordinateBounds bounds,
    required void Function(double) onProgress,
    required void Function() onComplete,
    required void Function(dynamic) onError,
    int? maxZoom,
    int? minZoom,
  }) async {
    try {
      // final maxZoomLevel = maxZoom ?? AppConstants.defaultMaxZoomLevel;
      // final minZoomLevel = minZoom ?? AppConfig.defaultMinZoomLevel;
      // Default max and min zoom level
      const maxZoomLevel = 22;
      const minZoomLevel = 1;
      // Logs the zoom level configurations for this region download process.
      if (kDebugMode) {
        print('downloadRegion: minZoom=$minZoomLevel, maxZoom=$maxZoomLevel');
      }

      // Calculates the total number of tiles required for the specified region and zoom levels
      final tileCount = calculateTileCount(bounds, minZoomLevel, maxZoomLevel);
      // Checks if the selected area would require too many tiles to download, throws an exception if exceeded.
      if (tileCount > 7122999999999250) {
        throw MapServiceException(
          'Selected area would require too many tiles. Please zoom in or select a smaller region. The selected area would require: $tileCount tiles',
          'Tile count too high',
        );
      }
       // Logs the start of the download process for the given region name
      if (kDebugMode) {
        print('Initializing download for region: $regionName');
      }
      // Initializes the map service, which prepares the offline manager, tile store, and notifications.
      await init();

      // Checks if the tile store is initialized. If null an exception is thrown.
      if (_tileStore == null) {
        throw MapServiceException(
          'TileStore is null after initialization',
          'TileStore is null',
        );
      }

      // Validate coordinates are within valid ranges, throwing an error if they aren't
      if (bounds.northeast.coordinates.lat > 90 ||
          bounds.northeast.coordinates.lat < -90 ||
          bounds.southwest.coordinates.lat > 90 ||
          bounds.southwest.coordinates.lat < -90 ||
          bounds.northeast.coordinates.lng > 180 ||
          bounds.northeast.coordinates.lng < -180 ||
          bounds.southwest.coordinates.lng > 180 ||
          bounds.southwest.coordinates.lng < -180) {
        throw MapServiceException(
          'Invalid coordinates. Latitude must be between -90 and 90, longitude between -180 and 180',
          'Invalid Coordinates',
        );
      }
      // Prints to console the start of the download region, also the coordinates and zoom level
      if (kDebugMode) {
        print('Starting download for region $regionName');
        print('Southwest: ${bounds.southwest.coordinates}');
        print('Northeast: ${bounds.northeast.coordinates}');
        print('Zoom levels: min=$minZoomLevel, max=$maxZoomLevel');
      }

      // Configure style pack load options for offline use
      final stylePackLoadOptions = StylePackLoadOptions(
        glyphsRasterizationMode:
            GlyphsRasterizationMode.IDEOGRAPHS_RASTERIZED_LOCALLY,
        metadata: {'tag': regionName},
        acceptExpired: true,
      );
      // Loads the style pack from a specified URI and updates the style pack loading progress.
      await _offlineManager?.loadStylePack(
          AppConstants.mapboxStreets, stylePackLoadOptions, (progress) {
           // Calculates the percentage of the completed style resources
        final percentage =
            progress.completedResourceCount / progress.requiredResourceCount;
             // Sends the current progress to the stream, only if the stream is not closed.
        if (!_stylePackProgress.isClosed) {
          _stylePackProgress.sink.add(percentage);
        }
        // After finishing, it closes the style pack progress stream.
      }).then((value) {
        _stylePackProgress.sink.add(1);
        _stylePackProgress.sink.close();
      });

      //  Creates a geometry object for the selected region
      final geometry = {
        'type': 'Polygon',
        'coordinates': [
          [
            [
              bounds.southwest.coordinates.lng,
              bounds.southwest.coordinates.lat,
            ],
            [
              bounds.northeast.coordinates.lng,
              bounds.southwest.coordinates.lat,
            ],
            [
              bounds.northeast.coordinates.lng,
              bounds.northeast.coordinates.lat,
            ],
            [
              bounds.southwest.coordinates.lng,
              bounds.northeast.coordinates.lat,
            ],
            [
              bounds.southwest.coordinates.lng,
              bounds.southwest.coordinates.lat,
            ],
          ]
        ],
      };

      // Logs the created geometry object in debug mode.
      if (kDebugMode) {
        print('Geometry created: $geometry');
      }
      //  Shows the notification to the user that a download has started for the region.
      await NotificationService.showProgressNotification(
        title: 'Downloading region',
        progress: 0,
        id: 1,
        indeterminate: true,
      );

      // Configure tile region load options
      final tileRegionLoadOptions = TileRegionLoadOptions(
        geometry: geometry,
        descriptorsOptions: [
          TilesetDescriptorOptions(
            styleURI: AppConstants.mapboxStreets,
            minZoom: minZoomLevel,
            maxZoom: maxZoomLevel,
          ),
        ],
        acceptExpired: true,
        networkRestriction: NetworkRestriction.NONE,
      );
      // Creates a unique region ID
      final regionId =
          '${bounds.southwest.coordinates.lng},${bounds.southwest.coordinates.lat}-${bounds.northeast.coordinates.lng},${bounds.northeast.coordinates.lat}';
      // Starts the process of downloading the tiles of a region, while also updating the progress stream.
      await _tileStore?.loadTileRegion(
        regionId,
        tileRegionLoadOptions,
        (progress) {
          // Calculates the percentage of the completed tiles.
          final percentage =
              progress.completedResourceCount / progress.requiredResourceCount;
          // Adds the current percentage to the stream, only if the stream is not closed
          if (!_tileRegionLoadProgress.isClosed) {
            _tileRegionLoadProgress.sink.add(percentage);
          }
          // Logs the progress information to the console
          if (kDebugMode) {
            print('progress.completedResourceCount');
            print(progress.completedResourceCount);
            print(progress.completedResourceSize);
            print(progress.erroredResourceCount);
            print(progress.loadedResourceCount);
            print(progress.loadedResourceSize);
          }
        },
      ).then((value) {
        // Adds 1 to the stream for completion and closes the stream.
        _tileRegionLoadProgress.sink.add(1);
        _tileRegionLoadProgress.sink.close();
      });

      // Logs the completion of download to console for a given region.
      if (kDebugMode) {
        print('Download complete for region: $regionName');
      }
      // Executes the callback for onComplete
      onComplete();
      // Removes the notification when the download has completed.
      await NotificationService.cancelNotification(1);
      //Catches any exceptions that happened during the download
    } on Exception catch (e, stackTrace) {
       // Prints to console the exception in debug mode
      if (kDebugMode) {
        print('Download failed with error: $e, StackTrace: $stackTrace');
      }
       // Executes the callback in case of error.
      onError(e);
       // Shows the notification to the user that download has failed.
      await NotificationService.showNotification(
        title: 'Download failed',
        body: e.toString(),
        id: 1,
      );
      // Removes the notification for the download after the error
      await NotificationService.cancelNotification(1);
        // Throws a custom exception to be handled by the caller
      throw MapServiceException('Download failed', e, stackTrace);
    }
  }

    /// Removes a tile region and its associated style pack.
  Future<void> removeTileRegionAndStylePack(
    String tileRegionId,
    String styleUri,
  ) async {
    try {
        // Retrieves the tile region using the tile id.
      final tileRegion = await _tileManagerService.getTileRegion(tileRegionId);
       // Checks if the tile region with this id exists before removing its style pack.
      if (tileRegion == null) {
          // Logs to console if a tile region doesn't exist
        if (kDebugMode) {
          print(
            'Tile region with id $tileRegionId does not exist, cannot remove style pack.',
          );
        }
        return;
      }
      // Prints to console the tile region and style pack being removed.
      if (kDebugMode) {
        print('Removing tile region and style pack: $tileRegionId, $styleUri');
      }
       // Removes the tile region, the tile store disk quota is set to zero and then removes the style pack using it's url
      await _tileManagerService.removeTileRegion(tileRegionId);
       _tileManagerService.tileStore?.setDiskQuota(0);
      await _offlineManager?.removeStylePack(styleUri);
    } catch (e, stackTrace) {
        // Prints to console if there was an error during the removal of tile region and style pack
      if (kDebugMode) {
        print(
          'Error removing tile region and style pack: $e, StackTrace: $stackTrace',
        );
      }
         // Throws a custom exception to be handled by the caller
      throw MapServiceException(
        'Error removing tile region and style pack',
        e,
        stackTrace,
      );
    }
  }

    /// Removes all tile regions by iterating through each region and its associated style pack.
  Future<void> removeAllTileRegions() async {
    try {
      // Get all tile regions
      final regions = await _tileManagerService.getAllTileRegions();
      // Loop over all of the tile regions
      for (final region in regions) {
        // remove the tile region and its style pack
        await removeTileRegionAndStylePack(
          region.id,
          AppConstants.mapboxStreets,
        );
      }
      // Catch any exception that occurred during the removal of tiles.
    } catch (e, stackTrace) {
       // Prints to console if there was an error removing all tile regions.
      if (kDebugMode) {
        print('Error removing all tile regions: $e, StackTrace: $stackTrace');
      }
      // Throws a custom exception to be handled by the caller
      throw MapServiceException(
        'Error removing all tile regions',
        e,
        stackTrace,
      );
    }
  }

  /// Closes the stream controllers used for tracking the download progress.
  void dispose() {
    _tileRegionLoadProgress.close();
    _stylePackProgress.close();
  }
}

/// Provider for the MapService, allowing access to map-related functionalities.
final mapServiceProvider = Provider<MapService>(
  (ref) => MapService(ref.watch(tileServiceProvider)),
);
############## End of /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/lib/core/services/map_service.dart ##############

############## Begin of /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/lib/core/services/storage_service.dart ##############
///
/// File: lib/core/services/storage_service.dart
/// Author: Adil AJDAA
/// Email: a.ajdaa@outlook.com
/// Purpose: Manages data storage using Hive for map markers and SharedPreferences for other settings.
/// Updates: Initial setup with methods to save, retrieve, and clear map markers, integers, strings, and booleans, and added comments
/// Used Libraries: flutter/foundation.dart, flutter_riverpod/flutter_riverpod.dart, hive_flutter/hive_flutter.dart, mobile/core/utils/app_constants.dart, mobile/shared/models/map_marker.dart, shared_preferences/shared_preferences.dart
///
library;
import 'package:flutter/foundation.dart'; // Import kDebugMode
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:hive_flutter/hive_flutter.dart';
import 'package:mobile/core/utils/app_constants.dart';
import 'package:mobile/shared/models/map_marker.dart';
import 'package:shared_preferences/shared_preferences.dart';

// Custom Exception for Storage service errors
class StorageException implements Exception {
  StorageException(this.message, this.error, [this.stackTrace]);
  final String message;
  final dynamic error;
  final StackTrace? stackTrace;

  @override
  String toString() =>
      'StorageException: $message, $error, stackTrace: $stackTrace';
}

/// Storage class that handles data storage for application
class Storage {
    /// Constructor for the storage class
  Storage();
    /// Future box for storing Map Markers in Hive
  late Future<Box<MapMarker>> _markerBoxFuture;
  /// Shared preferences instance to store simple data
  final Future<SharedPreferences> _prefsFuture =
      SharedPreferences.getInstance();

  /// Initializes the storage by setting up Hive and registering adapters for models.
  static Future<Storage> init() async {
    final storage = Storage();
    try {
       // Initializes hive for flutter storage
      await Hive.initFlutter();
      // Registers the needed adapters for the models
      Hive
        ..registerAdapter(MapMarkerAdapter())
        ..registerAdapter(GeometryAdapter())
        ..registerAdapter(GeometryTypeAdapter()); // Register the new adapter
         // Opens the box for storing the map markers, assigning it to a variable
      storage._markerBoxFuture =
          Hive.openBox<MapMarker>(AppConstants.markersKey);
       // Prints to the console in debug mode when storage is initialized.
      if (kDebugMode) {
        print('Storage Initialized');
      }
      // Returns the initialized storage.
      return storage;
      // Catches any exception that occurs during the storage initialization.
    } on Exception catch (e, stackTrace) {
      // Prints error to the console if there was a failure during initialization
      if (kDebugMode) {
        print('Error initializing storage: $e, StackTrace: $stackTrace');
      }
      // Throws custom exception when initialization fails.
      throw StorageException('Error initializing storage', e, stackTrace);
    }
  }

  // Marker operations

    /// Saves map markers to storage, clearing existing data first.
  Future<void> saveMarkers(List<MapMarker> markers) async {
    try {
       // Gets the map marker box.
      final markerBox = await _markerBoxFuture;
       // Clears the existing data from box.
      await markerBox.clear();
       // Puts all new markers in the box
      await markerBox.putAll(
        Map.fromIterables(
          markers.map((e) => e.id),
          markers,
        ),
      );
         // Gets a shared preference instance
      final prefs = await _prefsFuture;
       // Updates a timestamp for the markers.
      await prefs.setInt(
        AppConstants.markersKey,
        DateTime.now().millisecondsSinceEpoch,
      );
      //Catches any exception that occurs during the save operation
    } on Exception catch (e, stackTrace) {
      //Prints to the console if an error occurs during the saving
      if (kDebugMode) {
        print('Error saving markers: $e, StackTrace: $stackTrace');
      }
       // Throws custom exception when saving markers fails
      throw StorageException('Error saving markers', e, stackTrace);
    }
  }

    /// Retrieves map markers from storage.
  Future<List<MapMarker>> getMarkers() async {
    try {
         // Gets the map marker box.
      final markerBox = await _markerBoxFuture;
      // Returns all the values stored in the box as a list.
      return markerBox.values.toList();
    //Catches any exception that occurs during getting markers.
    } on Exception catch (e, stackTrace) {
      // Prints to console if an error occurs during retrieving markers.
      if (kDebugMode) {
        print('Error getting markers: $e, StackTrace: $stackTrace');
      }
      // Throws custom exception when getting markers fails.
      throw StorageException('Error getting markers', e, stackTrace);
    }
  }

  // Preferences operations

    /// Saves an integer value to shared preferences.
  Future<void> saveInt(String key, int value) async {
    try {
       // Gets shared preference instance.
      final prefs = await _prefsFuture;
      // Set the integer value for a given key
      await prefs.setInt(key, value);
    // Catches any exception that occurs while saving an int value.
    } on Exception catch (e, stackTrace) {
      // Prints to console if an error occurs while saving an integer
      if (kDebugMode) {
        print('Error saving int: $e, StackTrace: $stackTrace');
      }
      // Throws a custom exception when saving fails
      throw StorageException('Error saving int', e, stackTrace);
    }
  }

   /// Retrieves an integer value from shared preferences.
  Future<int?> getInt(String key) async {
    try {
        // Gets the shared preference instance
      final prefs = await _prefsFuture;
       // Returns the integer value for a given key
      return prefs.getInt(key);
    // Catches any exception that occurs while getting an int value.
    } on Exception catch (e, stackTrace) {
       // Prints to console if an error occurs while getting an integer
      if (kDebugMode) {
        print('Error getting int: $e, StackTrace: $stackTrace');
      }
      // Throws a custom exception when getting int fails
      throw StorageException('Error getting int', e, stackTrace);
    }
  }

   /// Saves a string value to shared preferences.
  Future<void> saveString(String key, String value) async {
    try {
         // Gets shared preference instance
      final prefs = await _prefsFuture;
       // Sets string value for the given key
      await prefs.setString(key, value);
    // Catches any exception that occurs while saving a string
    } on Exception catch (e, stackTrace) {
       // Prints to console if an error occurs while saving a string
      if (kDebugMode) {
        print('Error saving string: $e, StackTrace: $stackTrace');
      }
      // Throws custom exception when saving a string fails.
      throw StorageException('Error saving string', e, stackTrace);
    }
  }

    /// Retrieves a string value from shared preferences.
  Future<String?> getString(String key) async {
    try {
         // Gets shared preference instance.
      final prefs = await _prefsFuture;
         // Returns a string value for the given key
      return prefs.getString(key);
       // Catches any exception that occurs during getting a string.
    } on Exception catch (e, stackTrace) {
       // Prints to console if an error occurs while getting a string.
      if (kDebugMode) {
        print('Error getting string: $e, StackTrace: $stackTrace');
      }
      // Throws a custom exception when getting a string fails.
      throw StorageException('Error getting string', e, stackTrace);
    }
  }

    /// Saves a boolean value to shared preferences.
  Future<void> saveBool(String key, {required bool value}) async {
    try {
         // Gets shared preference instance
      final prefs = await _prefsFuture;
       // Saves a boolean value for a given key.
      await prefs.setBool(key, value);
      // Catches any exception that occurs during saving a boolean.
    } on Exception catch (e, stackTrace) {
      // Prints to console if an error occurs while saving a boolean value
      if (kDebugMode) {
        print('Error saving bool: $e, StackTrace: $stackTrace');
      }
       // Throws a custom exception when saving a boolean fails.
      throw StorageException('Error saving bool', e, stackTrace);
    }
  }

    /// Retrieves a boolean value from shared preferences.
  Future<bool?> getBool(String key) async {
    try {
        // Gets the shared preference instance.
      final prefs = await _prefsFuture;
        // Returns the boolean value for a given key
      return prefs.getBool(key);
       // Catches any exception that occurs during getting a bool.
    } on Exception catch (e, stackTrace) {
       // Prints to console if an error occurs while getting a boolean.
      if (kDebugMode) {
        print('Error getting bool: $e, StackTrace: $stackTrace');
      }
      // Throws a custom exception when getting a boolean fails.
      throw StorageException('Error getting bool', e, stackTrace);
    }
  }

  /// Clears all storage data, both Hive and SharedPreferences.
  Future<void> clearAll() async {
     // Prints to the console in debug mode before cleaning the storage.
    if (kDebugMode) {
      print('Clearing All Storage');
    }
    try {
        // Gets the map marker box
      final markerBox = await _markerBoxFuture;
      // Clears the marker box
      await markerBox.clear();
      // Gets the shared preferences
      final prefs = await _prefsFuture;
       // Clears all data from shared preferences
      await prefs.clear();
        // Prints to the console in debug mode when all the storage is cleared.
      if (kDebugMode) {
        print('All storage cleared');
      }
       //Catches any exception that occurs while clearing all the storage data.
    } on Exception catch (e, stackTrace) {
         // Prints to the console in debug mode when failing to clear the storage
      if (kDebugMode) {
        print('Error clearing storage: $e, StackTrace: $stackTrace');
      }
      //Throws custom exception when failing to clear all storage data.
      throw StorageException('Error clearing storage', e, stackTrace);
    }
  }
}

/// Provider for Storage, providing a single entry point to access storage functionalities.
final storageProvider = FutureProvider<Storage>((ref) async {
  final storage = await Storage.init();
  return storage;
});
############## End of /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/lib/core/services/storage_service.dart ##############

############## Begin of /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/lib/core/services/cache_service.dart ##############
///
/// File: lib/core/services/cache_service.dart
/// Author: Adil AJDAA
/// Email: a.ajdaa@outlook.com
/// Purpose: Manages the clearing of application cache, encompassing temporary files, map data, and storage.
/// Updates: Initial setup to clear temporary files, map data and app storage.
/// Used Libraries: flutter/foundation.dart, flutter_riverpod/flutter_riverpod.dart, mobile/core/performance/app_resource_optimizer.dart, mobile/core/services/map_service.dart, mobile/core/services/storage_service.dart, mobile/core/services/tile_service.dart
///
library;

import 'package:flutter/foundation.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:mobile/core/performance/app_resource_optimizer.dart';
import 'package:mobile/core/services/map_service.dart';
import 'package:mobile/core/services/storage_service.dart';
import 'package:mobile/core/services/tile_service.dart';

// Custom Exception for CacheService errors
class CacheServiceException implements Exception {
  CacheServiceException(this.message, this.error, [this.stackTrace]);
  final String message;
  final dynamic error;
  final StackTrace? stackTrace;

  @override
  String toString() =>
      'CacheServiceException: $message, $error, stackTrace: $stackTrace';
}

/// Manages clearing the application's cache, including temporary files, map data, and storage.
class CacheService {
    /// Constructor for CacheService, it takes `Storage`, `MapService`, and `TileService` as parameters
  CacheService(this.storage, this.mapService, this.tileManagerService);

    /// Storage service for managing preferences and map markers.
  final Storage storage;
    /// Map service for managing map-related operations.
  final MapService mapService;
  /// Tile service for managing offline tiles.
  final TileService tileManagerService;

  /// Clears the application's cache by removing temporary files, map data, and application data.
  Future<void> clearCache() async {
      //Prints to the console when clearCache is called
    if (kDebugMode) {
      print('clearCache is being called');
    }

    // Clear temporary files first, before clear map data
    try {
        // Clear all temp files using resource optimizer
      await AppResourceOptimizer.clearTempFiles();
        //Prints to the console if there was an error deleting temporary files
    } on Exception catch (e, stackTrace) {
      if (kDebugMode) {
        print('Error clearing temporaries: $e, StackTrace: $stackTrace');
      }
       // Throws an exception if there was an error during the cleaning process.
      throw CacheServiceException('Error clearing temporaries', e, stackTrace);
    }

    // clear map data
    if (kDebugMode) {
      print('About to clear Map Data');
    }
    // Remove region and style pack for all tiles
    try {
        // Removes all the tile regions and styles from the offline maps.
      await mapService.removeAllTileRegions();
       // Clears the old tiles in the device storage.
      await tileManagerService.clearOldTiles();
        //Prints to the console if there was an error while clearing map data.
    } on Exception catch (e, stackTrace) {
      if (kDebugMode) {
        print('Error clearing map data: $e, StackTrace: $stackTrace');
      }
      // Throws an exception if there was an error during the map data cleaning
      throw CacheServiceException('Error clearing map data', e, stackTrace);
    }

    // Clear application cache (example)
    try {
       // Clears all application storage
      await storage.clearAll();
        // Prints to the console when the cache has been successfully cleared.
      if (kDebugMode) {
        print('Cache has been cleared');
      }
      // Catches any exceptions that occurred during clearing the storage
    } on Exception catch (e, stackTrace) {
       // Prints to the console if there was an error while clearing the storage.
      if (kDebugMode) {
        print('Error clearing storage: $e, StackTrace: $stackTrace');
      }
      // Throws a custom exception in case of a failure
      throw CacheServiceException('Error clearing storage', e, stackTrace);
    }
  }
}

/// Provider for the CacheService, providing a single entry point to clear the cache.
final cacheManagerProvider = Provider<CacheService>(
  (ref) => CacheService(
    ref.watch(storageProvider).when(
          data: (data) => data,
          error: (error, stack) => throw CacheServiceException(
            'Storage Error: $error',
            error,
            stack,
          ),
          loading: Storage.new,
        ),
    ref.watch(mapServiceProvider),
    ref.watch(tileServiceProvider),
  ),
);
############## End of /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/lib/core/services/cache_service.dart ##############

############## Directory: /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/lib/core/services ##############

############## Directory: /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/lib/features ##############

############## Begin of /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/lib/features/settings/settings_screen.dart ##############
///
/// File: lib/features/settings/settings_screen.dart
/// Author: Adil AJDAA
/// Email: a.ajdaa@outlook.com
/// Purpose: Displays the settings screen, allowing users to change the application theme and clear data.
/// Updates: Initial setup with theme picker, clear data options, and downloaded region display.
/// Used Libraries: flutter/material.dart, flutter_riverpod/flutter_riverpod.dart, mobile/features/settings/settings_viewmodel.dart, mobile/shared/widgets/theme_picker.dart
///
library;
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:mobile/features/settings/settings_viewmodel.dart';
import 'package:mobile/shared/widgets/theme_picker.dart';

/// SettingsScreen widget provides UI to change app theme, clear data, and list downloaded regions.
class SettingsScreen extends ConsumerStatefulWidget {
  const SettingsScreen({super.key});

  @override
  ConsumerState<SettingsScreen> createState() => _SettingsScreenState();
}

class _SettingsScreenState extends ConsumerState<SettingsScreen> {
  @override
  void initState() {
    super.initState();
    // Adding a callback to load regions after the first frame renders.
    WidgetsBinding.instance.addPostFrameCallback((_) {
      ref.read(settingsViewModelProvider.notifier).loadRegions();
    });
  }

  @override
  Widget build(BuildContext context) {
    // Gets the view model to execute actions
    final settingsViewModel = ref.read(settingsViewModelProvider.notifier);
    return Scaffold(
       // AppBar with the title "Settings".
      appBar: AppBar(title: const Text('Settings')),
       // Padding and a column to arrange the components.
      body: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
           //Section title for the theme settings
            const Text(
              'Theme',
              style: TextStyle(fontSize: 20, fontWeight: FontWeight.bold),
            ),
            // Theme picker for changing application themes
            ThemePicker(
              onThemeChanged: settingsViewModel.changeTheme,
            ),
            const SizedBox(height: 20),
           //Section title for app performance settings
            const Text(
              'Performance',
              style: TextStyle(fontSize: 20, fontWeight: FontWeight.bold),
            ),
            // ListTile to clear the application cache.
            ListTile(
              title: const Text('Clear Data'),
              onTap: () {
                settingsViewModel.clearData(context);
              },
            ),
            // ListTile(
            //   title: const Text('Clear System Cache'),
            //   onTap: () {
            //     settingsViewModel.clearSystemCache(context);
            //   },
            // ),
            const SizedBox(height: 20),
            //Section title for the downloaded regions.
            const Text(
              'Downloaded Regions',
              style: TextStyle(fontSize: 20, fontWeight: FontWeight.bold),
            ),
            // List to show the downloaded regions
            // Expanded(
            //   child: Consumer(
            //     builder: (BuildContext context, WidgetRef ref, Widget? child) {
            //       final state = ref.watch(settingsViewModelProvider);
            //       return state.isLoading ? const Center(child: CircularProgressIndicator()) : ListView.builder(
            //         itemCount: state.regions.length,
            //         itemBuilder: (context, index) => RegionItem(
            //           region: state.regions[index],
            //           deleteRegion: (regionId) {
            //             settingsViewModel.deleteRegion(regionId);
            //           },
            //         ),
            //       );
            //     },
            //   ),
            // ),
          ],
        ),
      ),
    );
  }
}
############## End of /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/lib/features/settings/settings_screen.dart ##############

############## Begin of /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/lib/features/settings/settings_repository.dart ##############
///
/// File: lib/features/settings/settings_repository.dart
/// Author: Adil AJDAA
/// Email: a.ajdaa@outlook.com
/// Purpose: Data layer responsible for handling settings-related operations such as clearing the cache and retrieving downloaded regions.
/// Updates: Initial setup with methods to clear cache, get downloaded regions, and delete specific regions.
/// Used Libraries: flutter/foundation.dart, flutter_riverpod/flutter_riverpod.dart, mobile/core/services/cache_service.dart, mobile/core/services/tile_service.dart
///
library;
import 'package:flutter/foundation.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:mobile/core/services/cache_service.dart';
import 'package:mobile/core/services/tile_service.dart';

// Custom Exception for Settings repository errors
class SettingsRepositoryException implements Exception {
  SettingsRepositoryException(this.message, this.error, [this.stackTrace]);
  final String message;
  final dynamic error;
  final StackTrace? stackTrace;

  @override
  String toString() =>
      'SettingsRepositoryException: $message, $error, stackTrace: $stackTrace';
}

/// SettingsRepository class provides data handling methods for settings related functionalities.
class SettingsRepository {
    /// Constructor of the `SettingsRepository` which requires `CacheService` and `TileService`
  SettingsRepository(this._cacheManager, this._tileManagerService);
   /// Cache service instance for managing cache operations.
  final CacheService _cacheManager;
   /// Tile service instance for managing tile storage operations.
  final TileService _tileManagerService;

  /// Clears the application cache using the provided `CacheService`.
  Future<void> clearCache() async {
       // Prints to the console in debug mode before clearing the cache.
    if (kDebugMode) {
      print('Clearing Cache from Settings Repo');
    }
    try {
      // Clears the cache using cache manager
      await _cacheManager.clearCache();
     // Catches any exception and prints in debug mode
    } on Exception catch (e, stackTrace) {
      if (kDebugMode) {
        print('Error clearing cache: $e, StackTrace: $stackTrace');
      }
       // Throws a custom exception if there was an error during the clearing of the cache.
      throw SettingsRepositoryException('Error clearing cache', e, stackTrace);
    }
  }

    /// Retrieves downloaded regions from the tile manager.
  Future<List<String>> getDownloadedRegions() async {
    // Prints to the console in debug mode before retrieving the downloaded regions.
    if (kDebugMode) {
      print('Getting Downloaded regions from settings repo');
    }
    try {
        //Fetches all the tile regions from the tile manager service
      final regionsFuture = _tileManagerService.tileStore?.allTileRegions();

        //Return an empty list if no regions was found.
      if (regionsFuture == null) {
        if (kDebugMode) {
          print('No downloaded regions');
        }
        return [];
      }
      //Awaits the tile regions and converts them to a list of ids
      final regions = await regionsFuture;
       //Prints the list of downloaded regions to the console.
      if (kDebugMode) {
        print('Downloaded regions: ${regions.map((e) => e.id).toList()}');
      }
      // Returns the list of tile regions ids
      return regions.map((e) => e.id).toList();
      // Catches any exception and prints in debug mode.
    } on Exception catch (e, stackTrace) {
      if (kDebugMode) {
        print('Error getting downloaded regions: $e, StackTrace: $stackTrace');
      }
       // Throws a custom exception if there was an error while getting all downloaded regions
      throw SettingsRepositoryException(
        'Error getting downloaded regions',
        e,
        stackTrace,
      );
    }
  }

    /// Deletes a tile region using the tile manager.
  Future<void> deleteRegion(String regionId) async {
       //Prints to the console in debug mode before removing the given tile region.
    if (kDebugMode) {
      print('Deleting region from Settings repo: $regionId');
    }
    try {
       // Removes the given tile region using the tile id.
      await _tileManagerService.removeTileRegion(regionId);
      // Catches any exception and prints in debug mode
    } on Exception catch (e, stackTrace) {
      if (kDebugMode) {
        print('Error deleting region: $e, StackTrace: $stackTrace');
      }
       // Throws a custom exception if there was an error during deletion
      throw SettingsRepositoryException('Error deleting region', e, stackTrace);
    }
  }
}

/// Provider for the SettingsRepository to manage settings-related data.
final settingsRepositoryProvider = Provider<SettingsRepository>(
  (ref) => SettingsRepository(
    ref.watch(cacheManagerProvider),
    ref.watch(tileServiceProvider),
  ),
);
############## End of /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/lib/features/settings/settings_repository.dart ##############

############## Begin of /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/lib/features/settings/settings_viewmodel.dart ##############
///
/// File: lib/features/settings/settings_viewmodel.dart
/// Author: Adil AJDAA
/// Email: a.ajdaa@outlook.com
/// Purpose: Manages the state and logic for the settings screen, handling theme changes, data clearing, and region management.
/// Updates: Initial setup with theme change functionality, data clearing, loading regions, and Android-specific settings opening.
/// Used Libraries: android_intent_plus/android_intent.dart, android_intent_plus/flag.dart, flutter/foundation.dart, flutter/material.dart, flutter_riverpod/flutter_riverpod.dart, geolocator/geolocator.dart, mobile/core/services/storage_service.dart, mobile/core/services/tile_service.dart, mobile/core/utils/app_constants.dart, mobile/features/settings/settings_repository.dart, mobile/main.dart
///
library;
import 'package:android_intent_plus/android_intent.dart';
import 'package:android_intent_plus/flag.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:geolocator/geolocator.dart' as geo;
import 'package:mobile/core/services/storage_service.dart';
import 'package:mobile/core/services/tile_service.dart';
import 'package:mobile/core/utils/app_constants.dart';
import 'package:mobile/features/settings/settings_repository.dart';
import 'package:mobile/main.dart';

// Custom exception for SettingsViewModel errors.
class SettingsViewModelException implements Exception {
  SettingsViewModelException(this.message, this.error);
  final String message;
  final dynamic error;

  @override
  String toString() => 'SettingsViewModelException: $message, $error';
}

/// Represents the state of the settings view model.
class SettingsState {
   /// Constructor of the state class, sets the default values
  SettingsState({
    this.themeMode = ThemeMode.light,
    this.regions = const [],
    this.isLoading = false,
    this.message, // Add message for callbacks
  });
    /// Current selected theme mode.
  final ThemeMode themeMode;
  /// List of downloaded regions.
  final List<String> regions;
  /// Loading status.
  final bool isLoading;
    /// Message for feedback after completing an action or when an error occur.
  final String? message; // Add message for callbacks

  /// Creates a copy of the state with optional new properties.
  SettingsState copyWith({
    ThemeMode? themeMode,
    List<String>? regions,
    bool? isLoading,
    String? message,
  }) =>
      SettingsState(
        themeMode: themeMode ?? this.themeMode,
        regions: regions ?? this.regions,
        isLoading: isLoading ?? this.isLoading,
        message: message,
      );
}

/// Provider for the SettingsViewModel to manage state and logic for the settings screen.
final settingsViewModelProvider =
    StateNotifierProvider<SettingsViewModel, SettingsState>((ref) {
  final storageAsyncValue = ref.watch(storageProvider); // watch the AsyncValue
  // Handle the AsyncValue
  final storage = storageAsyncValue.when(
    data: (data) {
       // Prints a message in debug mode when the storage is loaded successfully
      if (kDebugMode) {
        print('SettingsViewModel: Storage loaded successfully');
      }
      return data;
    },
    error: (error, stack) {
       // Prints an error message with the stack trace to the console in debug mode.
      if (kDebugMode) {
        print(
          'SettingsViewModel: Error loading storage: $error, Stacktrace: $stack',
        );
      }
       // Throws a custom exception for error during the storage loading.
      throw SettingsViewModelException('Error loading storage', error);
    },
    loading: () {
        // Prints a message to the console when storage is loading.
      if (kDebugMode) {
        print('SettingsViewModel: Loading storage...');
      }
       // returns a default value during the loading.
      return null;
    },
  );

   // Return default view model if the storage is null.
  if (storage == null) {
      // Prints to the console when storage is null.
    if (kDebugMode) {
      print('SettingsViewModel: Storage is null, using default view model');
    }
      // Creates a SettingsViewModel with a default storage and other required instances
    return SettingsViewModel(
      ref.watch(settingsRepositoryProvider),
      ref.watch(tileServiceProvider),
      Future.value(Storage()),
      ref.watch(themeModeProvider.notifier),
      ref,
    );
  }
   // Creates a SettingsViewModel with the loaded storage and other required instances.
  return SettingsViewModel(
    ref.watch(settingsRepositoryProvider),
    ref.watch(tileServiceProvider),
    Future.value(storage),
    ref.watch(themeModeProvider.notifier),
    ref,
  );
});

/// SettingsViewModel manages the state and business logic for the settings screen.
class SettingsViewModel extends StateNotifier<SettingsState> {
  SettingsViewModel(
    this._repository,
    this._tileManagerService,
    this._storage,
    this._themeModeNotifier,
    this.ref,
  ) : super(SettingsState()) {
    // Executes after the storage is initialized, and loads the regions
    _storage.then((value) {
        // Checks if value is not null before trying to load the regions.
      // ignore: unnecessary_null_comparison
      if (value != null) {
        loadRegions();
      }
       //Prints to console if storage is not null.
      if (kDebugMode) {
        print('SettingsViewModel: Storage is not null, loading regions');
      }
    });
  }
  /// Settings repository instance for data operations
  final SettingsRepository _repository;
  ///  Tile service manager for managing tile storage operations.
  final TileService _tileManagerService;
  /// Controller for theme mode state.
  final StateController<ThemeMode> _themeModeNotifier;
  /// Future storage instance to retrieve from database.
  late final Future<Storage> _storage;
   /// Riverpod ref to update the state.
  final Ref ref;

    /// Changes the theme, saves the change to storage and updates the state.
  Future<void> changeTheme(ThemeMode themeMode) async {
    // Prints to the console in debug mode when the theme change starts.
    if (kDebugMode) {
      print(
        'SettingsViewModel: Attempting to change theme to: ${themeMode.name}',
      );
    }
    // returns when the state is not mounted.
    if (!mounted) {
      return;
    }
    // Set the new state of theme.
    _themeModeNotifier.state = themeMode;

    // Gets an instance of storage.
    final storage = await _storage;
     //Prints to the console in debug mode when the theme is being saved to storage
    if (kDebugMode) {
      print('SettingsViewModel: Saving theme to storage: ${themeMode.name}');
    }
    // Saves the theme to storage
    await storage.saveString(AppConstants.themeModeKey, themeMode.name);
     //Prints to the console in debug mode after the theme is saved to the storage.
    if (kDebugMode) {
      print('SettingsViewModel: Saved theme to storage: ${themeMode.name}');
    }
      // Prints to the console when theme changes and the state is set.
    if (kDebugMode) {
      print(
        'SettingsViewModel: Theme changed to: ${themeMode.name} setting state',
      );
    }
    // Set the new state for the view model.
    state = state.copyWith(themeMode: themeMode);
  }

    /// Loads the downloaded regions from repository and updates the state.
  Future<void> loadRegions() async {
      // Prints to the console in debug mode when the regions are being loaded.
    if (kDebugMode) {
      print('Loading Regions');
    }
    try {
        // Retrieves the downloaded regions using the repository.
      final regions = await _repository.getDownloadedRegions();
      // Prints the downloaded regions to the console.
      if (kDebugMode) {
        print('Loaded regions: $regions');
      }
      // returns when the state is not mounted.
      if (!mounted) {
        return;
      }
      // Updates the state with the new region.
      state = state.copyWith(regions: regions);
      // Catches any exception that occurs when loading the regions.
    } on Exception catch (e) {
        // Prints to the console the exception that occurred when loading regions
      if (kDebugMode) {
        print('Error loading regions: $e');
      }
       // Throws an exception with the error.
      throw SettingsViewModelException('Error loading regions', e);
    }
  }

   /// Clears application data (cache, markers), and reloads regions.
  Future<void> clearData(BuildContext context) async {
       // return if the state is not mounted.
    if (!mounted) {
      return;
    }
      // Updates the state to show loading.
    state = state.copyWith(isLoading: true);
     // Prints the console when the cache is about to get cleared
    if (kDebugMode) {
      print('Clearing cache');
    }
    try {
      // Clears the cache.
      await _repository.clearCache();
      // Reloads the regions after clearing the cache
      await loadRegions();
      // Returns when the state is not mounted
      if (!mounted) {
        return;
      }
       // Update the state to stop loading and to show a message to the user.
      state = state.copyWith(isLoading: false, message: 'Data cleared!');
        // Catches any exception that occurs when clearing data.
    } on Exception catch (e) {
       // Prints the error to console when the data failed to get cleared.
      if (kDebugMode) {
        print('Error clearing data: $e');
      }
       // Updates the state to stop loading and return error message.
      state =
          state.copyWith(isLoading: false, message: 'Error clearing data: $e');
          // Throws custom exception with the error message.
      throw SettingsViewModelException('Error clearing data', e);
    }
  }

    /// Opens the system app settings for the current application.
  Future<void> clearSystemCache(BuildContext context) async {
    // return if its a web platform
    if (kIsWeb) {
      return;
    }
     // Opens the app settings for android
    if (Theme.of(context).platform == TargetPlatform.android) {
      await _openAppSettings();
       // Shows a dialog on other platforms since there is no built in functionality
    } else {
      _showDialog(context);
    }
  }

  /// Opens the settings using AndroidIntent, it defaults to open settings using Geolocator if it fails.
  Future<void> _openAppSettings() async {
    try {
      // Using intent to launch settings for the current application
      final intent = AndroidIntent(
        action: 'action_application_details_settings',
        data: Uri(scheme: 'package', path: 'YOUR_PACKAGE_NAME').toString(),
        flags: [Flag.FLAG_ACTIVITY_NEW_TASK],
      );
      await intent.launch();
    } on Exception catch (e) {
      if (kDebugMode) {
        print('Could not open settings using AndroidIntent: $e');
      }
      // Opens settings using the geolocator package.
      await geo.Geolocator.openAppSettings();
    }
  }

    /// Shows a dialog for non-Android platforms to clear system cache manually.
  void _showDialog(BuildContext context) {
    showDialog(
      context: context,
      builder: (BuildContext context) => AlertDialog(
        title: const Text('Clear System Cache'),
        content: const Text(
          'To clear the system cache, please go to your device settings, select this app, and clear its cache manually.',
        ),
        actions: <Widget>[
          TextButton(
            child: const Text('OK'),
            onPressed: () {
              Navigator.of(context).pop();
            },
          ),
        ],
      ),
    );
  }

    /// Deletes a specified region using the repository and reloads regions.
  Future<void> deleteRegion(String regionId) async {
    try {
         // Deletes a region using it's id
      await _repository.deleteRegion(regionId);
       // Reload the regions after deletion.
      await loadRegions();
        // Catches any exception that occurs during deleting the regions.
    } on Exception catch (e) {
        // Prints the error to the console if the deletion fails.
      if (kDebugMode) {
        print('Error deleting region: $e');
      }
       // Throws a custom exception if the deletion of the region failed.
      throw SettingsViewModelException('Error deleting region', e);
    }
  }

  @override
  void dispose() {
      // Disposes of the tile manager service when the view model is disposed of.
    _tileManagerService.dispose();
    super.dispose();
  }
}
############## End of /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/lib/features/settings/settings_viewmodel.dart ##############

############## Directory: /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/lib/features/settings ##############

############## Begin of /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/lib/features/offline_map/offline_map_screen.dart ##############
///
/// File: lib/features/offline_map/offline_map_screen.dart
/// Author: Adil AJDAA
/// Email: a.ajdaa@outlook.com
/// Purpose: Displays the offline map screen, including controls for downloading and managing offline map regions.
/// Updates: Initial setup with a map widget, download dialog, regions management, zoom controls and current location functionalities.
/// Used Libraries: flutter/foundation.dart, flutter/material.dart, flutter_riverpod/flutter_riverpod.dart, mapbox_maps_flutter/mapbox_maps_flutter.dart, mobile/core/utils/app_constants.dart, mobile/core/utils/error_manager.dart, mobile/features/offline_map/offline_map_viewmodel.dart, mobile/shared/widgets/custom_error_widget.dart, mobile/shared/widgets/loading_overlay.dart, mobile/shared/widgets/map_controls.dart, mobile/shared/widgets/region_item.dart
///
library;
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:mapbox_maps_flutter/mapbox_maps_flutter.dart' as mb;
import 'package:mapbox_maps_flutter/mapbox_maps_flutter.dart';
import 'package:mobile/core/utils/app_constants.dart';
import 'package:mobile/core/utils/error_manager.dart';
import 'package:mobile/features/offline_map/offline_map_viewmodel.dart';
import 'package:mobile/shared/widgets/custom_error_widget.dart';
import 'package:mobile/shared/widgets/loading_overlay.dart';
import 'package:mobile/shared/widgets/map_controls.dart';
import 'package:mobile/shared/widgets/region_item.dart';

/// OfflineMapScreen provides UI for displaying and managing offline map regions.
class OfflineMapScreen extends ConsumerStatefulWidget {
  const OfflineMapScreen({super.key});

  @override
  ConsumerState<OfflineMapScreen> createState() => _OfflineMapScreenState();
}

class _OfflineMapScreenState extends ConsumerState<OfflineMapScreen> {
    /// Mapbox map object, which is going to be initialized once the map has been created.
  MapboxMap? _mapboxMap;
    /// Camera options for setting the initial map view
  late mb.CameraOptions _initialCameraOptions;
    ///  Selected city to download a region.
  String _selectedCity = '';

  /// Map with different cities configurations
  final Map<String, Map<String, double>> _cities = {
    'Casablanca': {
      'latitude': 33.5731104,
      'longitude': -7.5898434,
      'zoom': 11.0,
    },
    'Rabat': {
      'latitude': 34.020882,
      'longitude': -6.832477,
      'zoom': 11.0,
    },
    'Paris': {
      'latitude': 48.8566,
      'longitude': 2.3522,
      'zoom': 11.0,
    },
    'New York': {
      'latitude': 40.7128,
      'longitude': -74.0060,
      'zoom': 11.0,
    },
  };

  @override
  void initState() {
    super.initState();
    // Sets the default camera options for the map
    _initialCameraOptions = mb.CameraOptions(
      center: mb.Point(
        coordinates: mb.Position(
          AppConstants.defaultLongitude,
          AppConstants.defaultLatitude,
        ),
      ),
      zoom: AppConstants.defaultZoom,
    );
    // Loads the downloaded regions after the first frame renders.
    WidgetsBinding.instance.addPostFrameCallback((_) {
      ref.read(offlineMapViewModelProvider.notifier).loadRegions();
    });
  }

  @override
  Widget build(BuildContext context) => Scaffold(
        // AppBar for the offline map screen
        appBar: AppBar(
          title: const Text('Offline Maps'),
           // Action buttons for downloading regions and managing the downloaded regions.
          actions: [
            IconButton(
              icon: const Icon(Icons.download),
              onPressed: () => _showDownloadDialog(context),
            ),
            IconButton(
              icon: const Icon(Icons.map),
              onPressed: () => _showRegionsDialog(context),
            ),
          ],
        ),
        // Main body with a stack of elements.
        body: Stack(
          children: [
             // Map widget to display offline maps
            MapWidget(
              // styleUri: MapboxStyles.STANDARD,
              cameraOptions: _initialCameraOptions,
              onMapCreated: _onMapCreated,
            ),
             // Consumer for displaying error message
            Consumer(
              builder: (BuildContext context, WidgetRef ref, Widget? child) {
                final errorState = ref.watch(errorProvider);
                return errorState.message != null
                    ? CustomErrorWidget(
                        error: errorState.message!,
                        onClose: () =>
                            ref.read(errorProvider.notifier).clearError(),
                      )
                    : const SizedBox();
              },
            ),
            // Consumer for showing loading indicator while a region is being downloaded.
            Consumer(
              builder: (BuildContext context, WidgetRef ref, Widget? child) {
                final state = ref.watch(offlineMapViewModelProvider);
                return state.downloadStatus == DownloadStatus.downloading
                    ? LoadingOverlay(
                        message:
                            'Downloading Style Pack... ${(state.stylePackProgress * 100).toInt()}% \n Downloading Tiles... ${(state.downloadProgress * 100).toInt()}%',
                      )
                    : const SizedBox();
              },
            ),
           // Consumer for displaying the map zoom and current location buttons
            Consumer(
              builder: (BuildContext context, WidgetRef ref, Widget? child) {
                final state = ref.watch(offlineMapViewModelProvider);
                return MapControls(
                  onZoomIn: _zoomIn,
                  onZoomOut: _zoomOut,
                  onMoveToCurrentLocation: _moveToCurrentLocation,
                  isLocationLoading: state.isLocationLoading,
                );
              },
            ),
          ],
        ),
      );

   /// Callback called when the map has been created, updates the `_mapboxMap` variable.
  Future<void> _onMapCreated(MapboxMap mapboxMap) async {
    _mapboxMap = mapboxMap;
  }

    /// Downloads the currently selected city's map region.
  Future<void> _downloadCity(BuildContext context) async {
    try {
      // Checks if a city has been selected before starting the download process
      if (_selectedCity.isEmpty) {
        return;
      }
      // Gets the city configurations
      final city = _cities[_selectedCity]!;
        // Gets the coordinate bounds of the city using the current map
      final bounds = await _mapboxMap!.coordinateBoundsForCamera(
        CameraOptions(
          center: mb.Point(
            coordinates: mb.Position(
              city['longitude']!,
              city['latitude']!,
            ),
          ),
          zoom: city['zoom'],
        ),
      );
       // Prints download information when debug mode is enabled.
      if (kDebugMode) {
        print('Downloading city: $_selectedCity');
        print(
          'Southwest: lng: ${bounds.southwest.coordinates.lng}, lat: ${bounds.southwest.coordinates.lat}',
        );
        print(
          'Northeast: lng: ${bounds.northeast.coordinates.lng}, lat: ${bounds.northeast.coordinates.lat}',
        );
        print('Zoom levels: min: 1, max: 20');
        print('Starting download');
      }
      // Downloads the selected region, if the widget is still mounted.
      if (mounted) {
         // Pops up the dialog if the context is mounted.
        if (context.mounted) {
          Navigator.of(context).pop();
          await ref.read(offlineMapViewModelProvider.notifier).downloadRegion(
                bounds: bounds,
                minZoom: 1,
                maxZoom: 20,
                onProgress: (progress) {
                  if (kDebugMode) {
                    print('Download progress: ${progress * 100}%');
                  }
                },
                onComplete: () async {
                   // Prints to the console when the download is completed.
                  if (kDebugMode) {
                    final size = await ref
                        .read(offlineMapViewModelProvider.notifier)
                        .getRegionSize(bounds);
                    print('Download complete. Approximate size: $size');
                  }
                },
              );
        }
      }
      // Catches any exception that happens during the region download process
    } on Exception catch (e) {
      // Prints to the console if there is any error during download.
      if (kDebugMode) {
        print('Error fetching bounds or downloading region: $e');
      }
    }
  }

  /// Displays a dialog for downloading map regions.
  Future<void> _showDownloadDialog(BuildContext context) async {
    await showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Download Region'),
        content: SizedBox(
          width: MediaQuery.of(context).size.width * 0.8,
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              const Text('Select a City to Download'),
              const SizedBox(height: 16),
               // Dropdown button to select a city.
              DropdownButtonFormField<String>(
                decoration: const InputDecoration(
                  labelText: 'City',
                ),
                items: _cities.keys
                    .map<DropdownMenuItem<String>>(
                      (String value) => DropdownMenuItem<String>(
                        value: value,
                        child: Text(value),
                      ),
                    )
                    .toList(),
                onChanged: (value) {
                  _selectedCity = value ?? '';
                },
              ),
              const SizedBox(height: 16),
              // Download button to trigger download of the selected city region.
              ElevatedButton(
                onPressed: () => _downloadCity(context),
                child: const Text('Download'),
              ),
            ],
          ),
        ),
         // Action buttons to close or submit the form
        actions: [
          TextButton(
            child: const Text('Cancel'),
            onPressed: () {
              Navigator.of(context).pop();
            },
          ),
        ],
      ),
    );
  }

   /// Displays a dialog for managing downloaded map regions.
  Future<void> _showRegionsDialog(BuildContext context) async {
    await showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Downloaded Regions'),
        content: SizedBox(
          width: MediaQuery.of(context).size.width * 0.8,
          child: Consumer(
            builder: (BuildContext context, WidgetRef ref, Widget? child) {
              final state = ref.watch(offlineMapViewModelProvider);
              return state.isLoading
                  ? const Center(child: CircularProgressIndicator())
                   // List view that maps the downloaded regions.
                  : ListView.builder(
                      shrinkWrap: true,
                      itemCount: state.regions.length,
                      itemBuilder: (context, index) => RegionItem(
                        region: state.regions[index],
                        deleteRegion: (regionId) {
                          ref
                              .read(offlineMapViewModelProvider.notifier)
                              .deleteRegion(regionId);
                        },
                      ),
                    );
            },
          ),
        ),
         // Action button to close the dialog.
        actions: [
          TextButton(
            child: const Text('Close'),
            onPressed: () {
              Navigator.of(context).pop();
            },
          ),
        ],
      ),
    );
  }

   /// Zooms in on the map using the flyTo method with animation.
  Future<void> _zoomIn() async {
    if (_mapboxMap == null) {
      return;
    }
    final currentZoom =
        await _mapboxMap!.getCameraState().then((value) => value.zoom);
    await _mapboxMap!.flyTo(
      CameraOptions(zoom: currentZoom + 1),
      MapAnimationOptions(duration: 200),
    );
  }

    /// Zooms out on the map using the flyTo method with animation.
  Future<void> _zoomOut() async {
    if (_mapboxMap == null) {
      return;
    }
    final currentZoom =
        await _mapboxMap!.getCameraState().then((value) => value.zoom);
    await _mapboxMap!.flyTo(
      CameraOptions(zoom: currentZoom - 1),
      MapAnimationOptions(duration: 200),
    );
  }

    /// Moves the map camera to the current device location using the `moveToCurrentLocation` method from the view model.
  Future<void> _moveToCurrentLocation() async {
    if (_mapboxMap == null) {
      return;
    }
    await ref
        .read(offlineMapViewModelProvider.notifier)
        .moveToCurrentLocation(_mapboxMap!);
  }
}
############## End of /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/lib/features/offline_map/offline_map_screen.dart ##############

############## Begin of /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/lib/features/offline_map/offline_map_viewmodel.dart ##############
///
/// File: lib/features/offline_map/offline_map_viewmodel.dart
/// Author: Adil AJDAA
/// Email: a.ajdaa@outlook.com
/// Purpose: Manages the state and business logic for the offline map screen, including downloading regions, managing tile regions, and handling location services.
/// Updates: Initial setup with methods for loading regions, downloading regions, managing the download progress, removing tile regions, and moving to current location.
/// Used Libraries: dart/async.dart, flutter/foundation.dart, flutter_riverpod/flutter_riverpod.dart, geolocator/geolocator.dart, mapbox_maps_flutter/mapbox_maps_flutter.dart, mobile/core/services/map_service.dart, mobile/core/services/permission_service.dart, mobile/core/utils/app_constants.dart, mobile/core/utils/app_utils.dart, mobile/features/offline_map/offline_map_repository.dart
///
library;
import 'dart:async';

import 'package:flutter/foundation.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:geolocator/geolocator.dart' as geo;
import 'package:mapbox_maps_flutter/mapbox_maps_flutter.dart';
import 'package:mobile/core/services/map_service.dart';
import 'package:mobile/core/services/permission_service.dart';
import 'package:mobile/core/utils/app_constants.dart';
import 'package:mobile/core/utils/app_utils.dart';
import 'package:mobile/features/offline_map/offline_map_repository.dart';

// Custom exception for OfflineMapViewModel errors
class OfflineMapViewModelException implements Exception {
  OfflineMapViewModelException(this.message, this.error);
  final String message;
  final dynamic error;

  @override
  String toString() => 'OfflineMapViewModelException: $message, $error';
}

/// Represents the state of the offline map view model.
class OfflineMapState {
  OfflineMapState({
    this.isLoading = false,
    this.regions = const [],
    this.error,
    this.downloadStatus = DownloadStatus.idle,
    this.isLocationLoading = false,
    this.message,
    this.downloadProgress = 0,
    this.stylePackProgress = 0,
  });
  /// Flag to indicate that the data is loading
  final bool isLoading;
  /// List of TileRegion that have been downloaded
  final List<TileRegion> regions;
  /// Error message if any error occurred.
  final String? error;
    /// Flag to represent download status.
  final DownloadStatus downloadStatus;
    /// Loading state for the current location
  final bool isLocationLoading;
   /// Message to show the user after an action has been done or if an error occurred
  final String? message;
    /// Download progress as a value between 0 and 1.
  final double downloadProgress;
   /// Style pack download progress as a value between 0 and 1.
  final double stylePackProgress;

    /// Creates a copy of the current state with optional new values.
  OfflineMapState copyWith({
    bool? isLoading,
    List<TileRegion>? regions,
    String? error,
    DownloadStatus? downloadStatus,
    bool? isLocationLoading,
    String? message,
    double? downloadProgress,
    double? stylePackProgress,
  }) =>
      OfflineMapState(
        isLoading: isLoading ?? this.isLoading,
        regions: regions ?? this.regions,
        error: error,
        downloadStatus: downloadStatus ?? this.downloadStatus,
        isLocationLoading: isLocationLoading ?? this.isLocationLoading,
        message: message,
        downloadProgress: downloadProgress ?? this.downloadProgress,
        stylePackProgress: stylePackProgress ?? this.stylePackProgress,
      );
}

/// Provider for the OfflineMapViewModel, provides a single entry point to access the offline map functionalities
final offlineMapViewModelProvider =
    StateNotifierProvider.autoDispose<OfflineMapViewModel, OfflineMapState>(
  (ref) => OfflineMapViewModel(
    ref.watch(offlineMapRepositoryProvider),
    ref,
    ref.watch(mapServiceProvider),
  ),
);

/// Manages the state and logic for the offline map screen, handling downloads, location, and region management
class OfflineMapViewModel extends StateNotifier<OfflineMapState> {
  OfflineMapViewModel(this._repository, this.ref, this._mapService)
      : super(OfflineMapState());
   /// Offline map repository instance for fetching, downloading and deleting data
  final OfflineMapRepository _repository;
   /// Riverpod ref to update the state.
  final Ref ref;
  /// Map service instance, used to handle style packs and tile downloads.
  final MapService _mapService;
   /// Subscription object for listening to style pack loading progress.
  StreamSubscription<double>? _stylePackSubscription;
    /// Subscription object for listening to tile region download progress.
  StreamSubscription<double>? _tileRegionSubscription;

    /// Updates the state of the view model
  void updateState(OfflineMapState newState) {
    state = newState;
  }

    /// Loads downloaded regions and updates the state, sets loading to true and updates when completed
  Future<void> loadRegions() async {
      // returns if the state is not mounted.
    if (!mounted) {
      return;
    }
    // Updates the state to loading.
    updateState(state.copyWith(isLoading: true));
    try {
      // Gets all downloaded regions using the repository and updates the state accordingly.
      final regions = await _repository.getDownloadedRegions();
      // Returns when the state is not mounted.
      if (!mounted) {
        return;
      }
      // Updates the state with the loaded regions and sets loading to false.
      updateState(state.copyWith(regions: regions, isLoading: false));
       // Catches any exceptions and calls the utility error handler.
    } on Exception catch (e) {
      AppUtils.handleStateError(this, ref, state, e, e.toString());
    }
  }

   /// Downloads a specified map region, showing the progress and updating the state accordingly.
  Future<void> downloadRegion({
    required CoordinateBounds bounds,
    required int minZoom,
    required int maxZoom,
    required void Function(double) onProgress,
    required void Function() onComplete,
  }) async {
       // returns if the state is not mounted.
    if (!mounted) {
      return;
    }
    // Updates the state to downloading state and also sets the progress to zero.
    updateState(
      state.copyWith(
        downloadStatus: DownloadStatus.downloading,
        downloadProgress: 0,
        stylePackProgress: 0,
      ),
    );
       // Subscribes to the style pack progress stream
    _stylePackSubscription = _mapService.stylePackProgress.listen((progress) {
      //Updates the style pack progress when the state is mounted
      if (mounted) {
        updateState(state.copyWith(stylePackProgress: progress));
      }
      // Prints the style pack progress to the console in debug mode
      if (kDebugMode) {
        print('Style pack progress: ${progress * 100}%');
      }
    });
        // Subscribes to the tile region download progress stream.
    _tileRegionSubscription = _mapService.tileRegionProgress.listen((progress) {
       //Updates the tile download progress only if the state is mounted
      if (mounted) {
        updateState(state.copyWith(downloadProgress: progress));
      }
        // Prints the download progress to the console in debug mode
      if (kDebugMode) {
        print('Tile region progress: ${progress * 100}%');
      }
    });
    try {
       // Downloads the region using the repository and callbacks for success and failure
      await _repository.downloadRegion(
        regionName: 'region_${DateTime.now().millisecondsSinceEpoch}',
        bounds: bounds,
        onProgress: (progress) {
          if (kDebugMode) {
            print('Download progress: ${progress * 100}%');
          }
        },
        onComplete: () {
          // Update the state when the download is completed.
          if (mounted) {
            updateState(
              state.copyWith(downloadStatus: DownloadStatus.completed),
            );
            // Loads all the regions after completion.
            loadRegions();
          }
        },
        onError: (e) {
           // Calls a helper function for handling errors.
          AppUtils.handleStateError(this, ref, state, e, e.toString());
        },
        minZoom: minZoom,
        maxZoom: maxZoom,
      );
    // Catches any exceptions during the download process
    } on Exception catch (e) {
       // Calls a helper function to handle errors.
      AppUtils.handleStateError(this, ref, state, e, e.toString());
      // Disposes subscriptions
    } finally {
       // Cancels all of the subscriptions
      await _stylePackSubscription?.cancel();
      await _tileRegionSubscription?.cancel();
    }
  }

    /// Deletes a specified tile region and reloads all regions.
  Future<void> deleteRegion(String regionId) async {
       // Return if the state is not mounted.
    if (!mounted) {
      return;
    }
    // Updates the state to loading
    updateState(state.copyWith(isLoading: true));
    try {
      // Removes a tile region using the repository and loads all regions
      await _repository.removeTileRegion(regionId);
      await loadRegions();
      // Returns if the state is not mounted.
      if (!mounted) {
        return;
      }
      //Updates the state to stop loading
      updateState(state.copyWith(isLoading: false));
      // Catch any exception that occurs while deleting the tile region.
    } on Exception catch (e) {
       // Calls a helper function to handle errors.
      AppUtils.handleStateError(this, ref, state, e, e.toString());
    }
  }

    /// Clears all locally stored tiles.
  Future<void> clearAllTiles() async {
    try {
      // Clear all the locally stored tiles
      await _repository.clearOldTiles();
     // Handles exceptions by calling the error handler
    } on Exception catch (e) {
      AppUtils.handleStateError(this, ref, state, e, e.toString());
    }
  }

   /// Moves the map camera to the current device location
  Future<void> moveToCurrentLocation(MapboxMap map) async {
    // Returns if the state is not mounted.
    if (!mounted) {
      return;
    }
    // updates the state to is location loading
    updateState(state.copyWith(isLocationLoading: true));
    try {
      // Requests location permissions from the user.
      final permission = await PermissionService.requestLocationPermissions();
     // Handles the case when the user has permanently denied the permissions.
      if (permission == geo.LocationPermission.deniedForever) {
         // Updates the state and shows message to the user
        updateState(
          state.copyWith(
            isLocationLoading: false,
            message:
                'Location permissions permanently denied, please enable in settings.',
          ),
        );
        return;
      }
      // Handles the case when the user denies the permission and sets the default location on the map.
      if (permission == geo.LocationPermission.denied) {
           // Updates the state and shows message to the user
        updateState(
          state.copyWith(
            isLocationLoading: false,
            message: 'Location permissions denied, using default location.',
          ),
        );
        // Moves the map to the default location
        await map.flyTo(
          CameraOptions(
            center: Point(
              coordinates: Position(
                AppConstants.defaultLongitude,
                AppConstants.defaultLatitude,
              ),
            ),
            zoom: AppConstants.defaultZoom,
          ),
          MapAnimationOptions(duration: 200),
        );

        return;
      }
       // Gets current position from the geolocator plugin.
      final position = await geo.Geolocator.getCurrentPosition(
        desiredAccuracy: geo.LocationAccuracy.high,
      );
      // Moves the map to the user's current location
      await map.flyTo(
        CameraOptions(
          center: Point(
            coordinates: Position(position.longitude, position.latitude),
          ),
          zoom: AppConstants.defaultZoom,
        ),
        MapAnimationOptions(duration: 200),
      );
       // Catches any exception that occurs while getting current location.
    } on Exception catch (e, stackTrace) {
       // Logs any error while getting the user's current location in debug mode
      if (kDebugMode) {
        print('Error getting current location: $e, StackTrace: $stackTrace');
      }
      // Updates the state and shows a message to the user.
      updateState(
        state.copyWith(
          isLocationLoading: false,
          message: 'Error getting current location, using default location.',
        ),
      );
        // Moves the map to default location if error getting location.
      await map.flyTo(
        CameraOptions(
          center: Point(
            coordinates: Position(
              AppConstants.defaultLongitude,
              AppConstants.defaultLatitude,
            ),
          ),
          zoom: AppConstants.defaultZoom,
        ),
        MapAnimationOptions(duration: 200),
      );
     // Runs this block after the try and catch block regardless.
    } finally {
        // Updates the state to stop loading.
      if (mounted) {
        updateState(state.copyWith(isLocationLoading: false));
      }
    }
  }

   /// Retrieves the size of a specified region
  Future<String> getRegionSize(CoordinateBounds bounds) async {
    try {
       // Gets region size using the repository
      return await _repository.getRegionSize(bounds);
      // Catches any exception that occurred during getting region size.
    } on Exception catch (e) {
       // Prints to console if there is an error when getting the region size.
      if (kDebugMode) {
        print('Error getting region size from viewmodel: $e');
      }
       // Throws an exception for errors during getting the region size
      throw OfflineMapViewModelException('Error getting region size', e);
    }
  }

  @override
  void dispose() {
    // Cancels all of the stream subscriptions before disposing the view model.
    _stylePackSubscription?.cancel();
    _tileRegionSubscription?.cancel();
    super.dispose();
  }
}
############## End of /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/lib/features/offline_map/offline_map_viewmodel.dart ##############

############## Begin of /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/lib/features/offline_map/offline_map_repository.dart ##############
///
/// File: lib/features/offline_map/offline_map_repository.dart
/// Author: Adil AJDAA
/// Email: a.ajdaa@outlook.com
/// Purpose: Data layer responsible for handling offline map operations, such as downloading regions, managing tile data, and retrieving downloaded regions.
/// Updates: Initial setup with methods to download regions, retrieve downloaded regions, remove tile regions, clear old tiles, and get region size.
/// Used Libraries: flutter/foundation.dart, flutter_riverpod/flutter_riverpod.dart, mapbox_maps_flutter/mapbox_maps_flutter.dart, mobile/core/services/tile_service.dart, mobile/core/utils/app_utils.dart
///
library;
import 'package:flutter/foundation.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:mapbox_maps_flutter/mapbox_maps_flutter.dart';
import 'package:mobile/core/services/tile_service.dart';
import 'package:mobile/core/utils/app_utils.dart';

/// OfflineMapRepository class provides data handling methods for offline map related functionalities.
class OfflineMapRepository {
  /// Constructor for the `OfflineMapRepository` which requires a `TileService`
  OfflineMapRepository(this._tileService);
  /// Tile service instance for managing offline tiles
  final TileService _tileService;

   /// Downloads the specified map region using the `TileService`.
  Future<void> downloadRegion({
    required String regionName,
    required CoordinateBounds bounds,
    required void Function(double) onProgress,
    required void Function() onComplete,
    required void Function(dynamic) onError,
    int? maxZoom,
    int? minZoom,
  }) async {
    try {
      // Downloads the tiles for a region with the provided parameters using the TileService.
      await _tileService.downloadTiles(
        bounds,
        minZoom ?? 10,
        maxZoom ?? 15,
        'mapbox://styles/mapbox/streets-v12',
      );
      // Triggers the onComplete callback when the download completes
      onComplete();
       // Catches any exception that occurs during download
    } on Exception catch (e, stackTrace) {
        // Prints to console the exception message in debug mode if the download fails.
      if (kDebugMode) {
        print(
          'Error downloading region from repo $regionName: $e, StackTrace: $stackTrace',
        );
      }
      // Triggers the onError callback, passing in the error.
      onError(e);
    }
  }

    /// Retrieves all downloaded tile regions from the `TileService`.
  Future<List<TileRegion>> getDownloadedRegions() async {
    try {
      // Gets all available tile regions from the TileService.
      return await _tileService.getAllTileRegions();
    // Catches any exception that occurs while getting all the tile regions.
    } on Exception catch (e, stackTrace) {
       // Prints to the console the error message in debug mode.
      if (kDebugMode) {
        print(
          'Error getting all tile regions from repo: $e, StackTrace: $stackTrace',
        );
      }
       // Re-throws the exception with additional context.
      throw Exception(
        'Error getting all tile regions: $e, StackTrace: $stackTrace',
      );
    }
  }

   /// Removes a specific tile region by its ID using the `TileService`.
  Future<void> removeTileRegion(String regionId) async {
    try {
      // Removes the tile region using the provided id in the tile service.
      await _tileService.removeTileRegion(regionId);
       // Catches any exception that occurs while removing the tile region.
    } on Exception catch (e, stackTrace) {
         // Prints the error to console when it fails to delete the tile region.
      if (kDebugMode) {
        print(
          'Error deleting tile region $regionId from repo: $e, StackTrace: $stackTrace',
        );
      }
       // Re-throws the exception with additional context.
      throw Exception(
        'Error deleting tile region $regionId: $e, StackTrace: $stackTrace',
      );
    }
  }

    /// Clears all locally stored old tiles using the `TileService`.
  Future<void> clearOldTiles() async {
    try {
        // Clears all the old tiles using tile service
      await _tileService.clearOldTiles();
         // Catches any exception that occurs during clearing old tiles
    } on Exception catch (e, stackTrace) {
        // Prints error to the console when cleaning the tiles fails.
      if (kDebugMode) {
        print('Error clear all tiles from repo: $e, StackTrace: $stackTrace');
      }
       // Re-throws the exception with additional context.
      throw Exception('Error clear all tiles: $e, StackTrace: $stackTrace');
    }
  }

    /// Gets the size of a specified region using its bounds from the `TileService`
  Future<String> getRegionSize(CoordinateBounds bounds) async {
    try {
      // Creates the region id using the bounds
      final regionId =
          '${bounds.southwest.coordinates.lng},${bounds.southwest.coordinates.lat}-${bounds.northeast.coordinates.lng},${bounds.northeast.coordinates.lat}';
      // Get the tile region from the tile service with given region id.
      final tileRegion = await _tileService.getTileRegion(regionId);
       // Returns "0 B" if no tile region is available.
      if (tileRegion == null) {
        return '0 B';
      }
        // Gets the complete resource size of the region.
      final sizeBytes = tileRegion.completedResourceSize;
      // Formats the size to a human readable format and returns it
      return AppUtils.formatFileSize(sizeBytes);
        // Catches any exception that occurs during getting region size
    } on Exception catch (e, stackTrace) {
         // Prints to the console in debug mode when there is an error when getting region size.
      if (kDebugMode) {
        print(
          'Error getting region size from repo: $e, StackTrace: $stackTrace',
        );
      }
      // Re-throws exception when it failed to get the region size.
      throw Exception('Error getting region size: $e, StackTrace: $stackTrace');
    }
  }
}

/// Provider for the OfflineMapRepository, provides a single entry point for the offline map data.
final offlineMapRepositoryProvider = Provider<OfflineMapRepository>(
  (ref) => OfflineMapRepository(
    ref.watch(tileServiceProvider),
  ),
);
############## End of /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/lib/features/offline_map/offline_map_repository.dart ##############

############## Directory: /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/lib/features/offline_map ##############

############## Begin of /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/lib/features/map/map_repository.dart ##############
///
/// File: lib/features/map/map_repository.dart
/// Author: Adil AJDAA
/// Email: a.ajdaa@outlook.com
/// Purpose: Data layer responsible for fetching map markers from a REST API and managing local storage.
/// Updates: Initial setup with methods to retrieve map markers from API, handle caching, and update markers.
/// Used Libraries: dartz/dartz.dart, dio/dio.dart, flutter/foundation.dart, flutter_riverpod/flutter_riverpod.dart, mobile/core/config/app_config.dart, mobile/core/services/network_service.dart, mobile/core/services/storage_service.dart, mobile/core/utils/app_constants.dart, mobile/shared/models/map_marker.dart
///
library;
import 'package:dartz/dartz.dart';
import 'package:dio/dio.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:mobile/core/config/app_config.dart';
import 'package:mobile/core/services/network_service.dart';
import 'package:mobile/core/services/storage_service.dart';
import 'package:mobile/core/utils/app_constants.dart';
import 'package:mobile/shared/models/map_marker.dart';

/// MapRepository class provides data handling methods for map related functionalities.
class MapRepository {
  /// Constructor for the `MapRepository`, it takes instances of `NetworkService` and `Storage`.
  MapRepository(this._network, this._storage);
    /// Network service instance for making api calls.
  final NetworkService _network;
  /// Storage service for managing the local storage.
  final Storage _storage;

    /// Fetches map markers from the API or local storage based on refresh status, returning an Either type.
  Future<Either<MapRepositoryException, List<MapMarker>>> getMarkers({
    bool forceRefresh = false,
  }) async {
    // Gets last update for markers from local storage
    final lastUpdate = await _storage.getInt(AppConstants.markersKey);
    //  Checks if force refresh is false and if there is a last update in local storage.
    if (!forceRefresh) {
      if (lastUpdate != null) {
        // Calculates the time difference
        final now = DateTime.now().millisecondsSinceEpoch;
        final diff = now - lastUpdate;
         //Checks if the cache is valid by checking if the last update was within the last 10 minutes.
        if (diff < const Duration(minutes: 10).inMilliseconds) {
             // Gets the markers from local storage if the cache is valid.
          final cached = await _storage.getMarkers();
             // Returns the cached markers if they are not empty.
          if (cached.isNotEmpty) {
             // Prints a message to console if it is returning cached markers in debug mode.
            if (kDebugMode) {
              print('Returning cached markers');
            }
            return Right(cached);
          }
        }
      }
    }
      // Try to retrieve the data from the API
    try {
       // Prints the get request to console in debug mode
      if (kDebugMode) {
        print('Request: GET ${AppConfig.locationsPath}');
      }
      // Makes the request to retrieve the data
      final response = await _network.get(AppConfig.locationsPath);
      // Prints the response status code and the url
      if (kDebugMode) {
        print('Response: ${response.statusCode} ${response.realUri}');
      }
      // Validates the status code
      if (response.statusCode != 200) {
         // Returns an error if the status code is different than 200
        return Left(
          MapRepositoryException(
            'Error getting markers from API - Status code: ${response.statusCode}',
            response.statusCode,
          ),
        );
      }
       // Gets the response data
      final responseData = response.data;
       // Returns an error if the response format is not correct.
      if (responseData == null || responseData is! Map<String, dynamic>) {
        return Left(
          MapRepositoryException('Invalid response format', responseData),
        );
      }
       // Parses the result to a map and a list of map markers
      final results = responseData['results'] as List<dynamic>;
      final markers = <MapMarker>[];
      var validMarkers = 0;
      // Iterates over the results and creates map marker models.
      for (final json in results) {
        try {
          final marker = _parseMapMarker(json as Map<String, dynamic>);
          // Validates that a marker has valid coordinates before adding it to the list
          if (marker.geometry.coordinates.isNotEmpty) {
            markers.add(marker);
            validMarkers++;
            // Logs to the console in debug mode when a marker has null coordinates
          } else {
            if (kDebugMode) {
              print('Marker with null coordinates, id: ${marker.id}');
            }
          }
        // Catches any exception during the parsing of a marker
        } on Exception catch (e, stackTrace) {
           // Prints to console when parsing of a marker fails.
          if (kDebugMode) {
            print('Error parsing marker: $e, StackTrace: $stackTrace');
          }
        }
      }
       // Check if there are valid markers to save
      if (markers.isNotEmpty) {
         // Saves the markers to local storage
        await _storage.saveMarkers(markers);
        // Prints the number of the markers to the console
        if (kDebugMode) {
          print('Returning $validMarkers markers from API');
        }
          // Returns a list of valid markers
        return Right(markers);
          // Returns empty list when there are no valid markers
      } else {
         // Prints a log message to the console if there are no valid markers available from API
        if (kDebugMode) {
          print('No valid markers available from API');
        }
         // Returns an empty array if there are no valid markers from the api.
        return const Right([]);
      }
     // Catches any exception that happens during fetching the markers from api
    } on DioException catch (e, stackTrace) {
        // Prints to console in debug mode that the data is going to be retrieved from cache
      if (kDebugMode) {
        print('Error getting markers from API, loading from cache');
      }
      // Gets the cached markers.
      final cached = await _storage.getMarkers();
      // If cache isn't empty, returns cached markers.
      if (cached.isNotEmpty) {
        return Right(cached);
      }
        // Prints an error message in debug mode
      if (kDebugMode) {
        print('Error getting markers: $e, StackTrace: $stackTrace');
      }
      // Returns an error exception
      return Left(
        MapRepositoryException(
          'Error getting markers from API',
          e,
          stackTrace,
        ),
      );
       // Catches any exception that happens during fetching the markers from api or cache
    } on Exception catch (e, stackTrace) {
      //Prints to console in debug mode that there is an error getting the data, and trying to load from cache
      if (kDebugMode) {
        print('Error getting markers from API, loading from cache');
      }
      // Get's the markers from local storage
      final cached = await _storage.getMarkers();
      // Returns the markers if the cached markers is not empty.
      if (cached.isNotEmpty) {
        return Right(cached);
      }
        // Prints the exception to the console.
      if (kDebugMode) {
        print('Error getting markers: $e, StackTrace: $stackTrace');
      }
      // Returns a generic exception.
      return Left(
        MapRepositoryException(
          'Error getting markers from API',
          e,
          stackTrace,
        ),
      );
    }
  }

  /// Parses a map marker from a JSON object
  MapMarker _parseMapMarker(Map<String, dynamic> json) {
    // Gets the geometry from the json
    final dynamic geometry = json['geometry'];
    // Returns a MapMarker object with default coordinates if geometry is null.
    if (geometry == null) {
        // Prints to console when geometry is null for a marker in debug mode
      if (kDebugMode) {
        print('Geometry is null for marker: ${json['id']}');
      }
      return MapMarker(
        id: json['id'] as String,
        title: json['name'] as String,
        description: json['description'] ?? '',
        geometry: Geometry(
          type: GeometryType.point,
          coordinates: [
            AppConstants.defaultLongitude,
            AppConstants.defaultLatitude,
          ],
        ),
      );
    }

      // Throws an error if the geometry is not a Map.
    if (geometry is! Map<String, dynamic>) {
      throw ArgumentError(
        'Invalid geometry format, the value was not a object: $geometry',
      );
    }
      // Returns a MapMarker from a JSON object.
    return MapMarker(
      id: json['id'] as String,
      title: json['name'] as String,
      description: json['description'] ?? '',
      geometry: Geometry.fromJson(geometry),
    );
  }

   /// Updates a map marker using the provided data.
  Future<void> updateMarker(MapMarker marker) async {
    try {
       // Send a put request to update the given marker using it's id.
      await _network.put('/locations/${marker.id}', marker.toJson());
      // Gets the markers from the storage.
      final markers = await _storage.getMarkers();
       // Convert the list of markers into a map using their ids as a key.
      final markersMap = {for (final m in markers) m.id: m};
       // Updates the marker from the map.
      markersMap[marker.id] = marker;
       // Convert the updated markers back to a list
      final updatedMarkers = markersMap.values.toList();
        // Save the markers to the storage.
      await _storage.saveMarkers(updatedMarkers);
        // Catch any exceptions while updating the marker.
    } on Exception catch (e, stackTrace) {
      // Prints an error to the console if it fails to update the marker in debug mode.
      if (kDebugMode) {
        print('Error updating marker: $e, StackTrace: $stackTrace');
      }
      // Throw a custom exception if there is a failure updating the marker.
      throw MapRepositoryException('Error updating marker', e, stackTrace);
    }
  }
}

/// Provider for the MapRepository, provides a single entry point to access map marker functionalities.
final mapRepositoryProvider = Provider<MapRepository>(
  (ref) => MapRepository(
    ref.watch(networkServiceProvider),
    ref.watch(storageProvider).when(
          data: (data) => data,
          error: (error, stack) => throw MapRepositoryException(
            'Storage loading error',
            error,
            stack,
          ),
          loading: Storage.new,
        ),
  ),
);

// Custom exception for MapRepository errors
class MapRepositoryException implements Exception {
  MapRepositoryException(this.message, this.error, [this.stackTrace]);
  final String message;
  final dynamic error;
  final StackTrace? stackTrace;
  @override
  String toString() =>
      'MapRepositoryException: $message, $error, stackTrace: $stackTrace';
}
############## End of /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/lib/features/map/map_repository.dart ##############

############## Begin of /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/lib/features/map/map_viewmodel.dart ##############
///
/// File: lib/features/map/map_viewmodel.dart
/// Author: Adil AJDAA
/// Email: a.ajdaa@outlook.com
/// Purpose: Manages the state and logic for the map screen, including loading markers, handling location services, and moving the map to the first marker or current location.
/// Updates: Initial setup with loading markers, moving to first marker, clearing markers, and handling location services with current location functionality.
/// Used Libraries: flutter/foundation.dart, flutter_riverpod/flutter_riverpod.dart, geolocator/geolocator.dart, mapbox_maps_flutter/mapbox_maps_flutter.dart, mobile/core/services/map_service.dart, mobile/core/services/permission_service.dart, mobile/core/utils/app_constants.dart, mobile/core/utils/app_utils.dart, mobile/core/utils/context_provider.dart, mobile/features/map/map_repository.dart, mobile/shared/models/map_marker.dart
///
library;
import 'package:flutter/foundation.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:geolocator/geolocator.dart' as geo;
import 'package:mapbox_maps_flutter/mapbox_maps_flutter.dart';
import 'package:mobile/core/services/map_service.dart';
import 'package:mobile/core/services/permission_service.dart';
import 'package:mobile/core/utils/app_constants.dart';
import 'package:mobile/core/utils/app_utils.dart';
import 'package:mobile/core/utils/context_provider.dart';
import 'package:mobile/features/map/map_repository.dart';
import 'package:mobile/shared/models/map_marker.dart' as map_marker;

// Custom exception for MapViewModel errors
class MapViewModelException implements Exception {
  MapViewModelException(this.message, this.error, [this.stackTrace]);
  final String message;
  final dynamic error;
  final StackTrace? stackTrace;

  @override
  String toString() =>
      'MapViewModelException: $message, $error, stackTrace: $stackTrace';
}

/// Represents the state of the map view model
class MapState {
  MapState({
    this.isLoading = false,
    this.markers = const [],
    this.error,
    this.isOffline = false,
    this.didFetchSuccessfully = false,
    this.isLocationLoading = false,
    this.message,
  });
  ///  Flag to represent the loading state
  final bool isLoading;
    /// List of map markers to display on the map
  final List<map_marker.MapMarker> markers;
   /// Error message if any error has occurred
  final String? error;
    /// Flag indicating if the app is in offline mode
  final bool isOffline;
   /// Flag indicating if the markers were successfully fetched
  final bool didFetchSuccessfully;
    ///  Loading state for the current location functionality
  final bool isLocationLoading;
    /// Message for feedback to the user, like success or error messages
  final String? message;

    /// Create a copy of the state with updated values.
  MapState copyWith({
    bool? isLoading,
    List<map_marker.MapMarker>? markers,
    String? error,
    bool? isOffline,
    bool? didFetchSuccessfully,
    bool? isLocationLoading,
    String? message,
  }) =>
      MapState(
        isLoading: isLoading ?? this.isLoading,
        markers: markers ?? this.markers,
        error: error,
        isOffline: isOffline ?? this.isOffline,
        didFetchSuccessfully: didFetchSuccessfully ?? this.didFetchSuccessfully,
        isLocationLoading: isLocationLoading ?? this.isLocationLoading,
        message: message,
      );
}

/// Provider for the MapViewModel to manage the state and logic for the map screen.
final mapViewModelProvider = StateNotifierProvider<MapViewModel, MapState>(
  (ref) => MapViewModel(
    ref.watch(mapRepositoryProvider),
    ref.watch(mapServiceProvider),
    ref,
  ),
);

/// MapViewModel manages the state and business logic for the map screen.
class MapViewModel extends StateNotifier<MapState> {
  /// Constructor for `MapViewModel`, it takes an instance of `MapRepository`, `MapService`, and a `Ref`
  MapViewModel(this._repository, this._mapService, this.ref)
      : super(MapState());
   /// Map repository instance for fetching and updating data.
  final MapRepository _repository;
   /// Map service instance for tile downloads and style management
  final MapService _mapService;
    /// Riverpod ref to update the state
  final Ref<MapState> ref;
   /// Mapbox map instance to perform map related operations.
  MapboxMap? _map;
  
    ///  Sets the MapboxMap instance for the view model.
  void setMap(MapboxMap map) {
    _map = map;
    // Initializes map service
    _mapService.init();
  }

    /// Loads the map markers from the API or local storage, handles errors and loading states, using an Either type.
  Future<void> loadMarkers({bool forceRefresh = false}) async {
     // return if the state is not mounted
    if (!mounted) {
      return;
    }
    // Prints a message to the console before getting the markers.
    if (kDebugMode) {
      print(
        'MapViewModel: loadMarkers started with forceRefresh: $forceRefresh',
      );
    }
    // Sets the state to loading.
    state = state.copyWith(isLoading: true);
    try {
       // Fetches the markers from the repository
      final result = await _repository.getMarkers(forceRefresh: forceRefresh);
       // Returns if the state is not mounted
      if (!mounted) {
        return;
      }

      // Handles the Either type (Right(data) or Left(error))
      result.fold((error) {
        // Prints the error message to the console in debug mode.
        if (kDebugMode) {
          print('MapViewModel: MapRepositoryException: $error');
        }
          // Handles the error using the utility class and shows snackbar to the user if the context is available
        if (mounted && ref.read(contextProvider) != null) {
           // Prints to console before calling the app utils helper to handle the errors
          if (kDebugMode) {
            print('MapViewModel: Calling AppUtils.handleStateError');
          }
          AppUtils.handleStateError(
            this,
            ref,
            state,
            error,
            '${AppConstants.unableToLoadMarkersError}: ${error.toString()}',
          );
        }
        // Prints the error to the console in debug mode
        if (kDebugMode) {
          print('MapViewModel: setting error state: ${error.toString()}');
        }
        // Updates the state with an error message and stop loading.
        state = state.copyWith(
          isLoading: false,
          error:
              '${AppConstants.unableToLoadMarkersError}: ${error.toString()}',
        );
        // Handles the markers in the Right of Either type.
      }, (data) {
        // Prints to the console the number of markers when using API
        if (kDebugMode) {
          print('MapViewModel: Loaded markers: ${data.length} from API');
        }
        // Updates the state with the markers, setting the offline status, load status and message.
        state = state.copyWith(
          isLoading: false,
          markers: data,
          isOffline: false,
          didFetchSuccessfully: data.isNotEmpty,
          message: data.isNotEmpty
              ? '${data.length} markers added from a total of ${data.length} results'
              : null,
        );
          // Moves the camera to the first marker in the markers list
        if (data.isNotEmpty) {
          moveToFirstMarker();
        }
      });
        // Catches any exceptions and handles them using the utility function for errors
    } on Exception catch (e) {
        // Prints the exception to the console in debug mode
      if (kDebugMode) {
        print('MapViewModel: Generic Exception: $e');
      }
        // Handles the error using the app utility class.
      if (mounted && ref.read(contextProvider) != null) {
          // Prints to console that it's calling the error helper function.
        if (kDebugMode) {
          print(
            'MapViewModel: Calling AppUtils.handleStateError on Generic Exception',
          );
        }
        AppUtils.handleStateError(
          this,
          ref,
          state,
          e,
          '${AppConstants.unableToLoadMarkersError}: ${e.toString()}',
        );
      }
      // Prints to the console that is setting the error state
      if (kDebugMode) {
        print('MapViewModel: setting error state: ${e.toString()}');
      }
      // Updates the state with an error message
      state = state.copyWith(
        isLoading: false,
        error: '${AppConstants.unableToLoadMarkersError}: ${e.toString()}',
      );
    }
  }

  /// Moves the camera to the first marker in the list, if any exist
  Future<void> moveToFirstMarker() async {
     // return if map is null
    if (_map == null) {
      return;
    }
      // Checks if there is any marker in the list
    if (state.markers.isNotEmpty) {
         // gets the first marker.
      final firstMarker = state.markers.first;
       // Validates that there are coordinates before moving the map camera.
      if (firstMarker.geometry.coordinates.isNotEmpty &&
          firstMarker.geometry.type == map_marker.GeometryType.point) {
        // Moves the map to the first marker
        await _map?.flyTo(
          CameraOptions(
            center: Point(
              coordinates: Position(
                firstMarker.geometry.coordinates[0],
                firstMarker.geometry.coordinates[1],
              ),
            ),
            zoom: AppConstants.defaultZoom,
          ),
          MapAnimationOptions(duration: 200),
        );
      }
    }
  }

   /// Clears the current markers from the state.
  Future<void> clearMarkers() async {
      // Return if state is not mounted
    if (!mounted) {
      return;
    }
    // Sets the markers to empty list
    state = state.copyWith(markers: []);
  }

  /// Moves the map camera to the current device location using the `MapService` or default coordinates when the permission has been denied.
  Future<void> moveToCurrentLocation(MapboxMap map) async {
     // Returns when the state is not mounted.
    if (!mounted) {
      return;
    }
      // Sets isLocationLoading to true.
    state = state.copyWith(isLocationLoading: true);
    try {
       // Requests permission for location from the user
      final permission = await PermissionService.requestLocationPermissions();
       // Handles the case when location permission has been permanently denied
      if (permission == geo.LocationPermission.deniedForever) {
         // Updates the state with a specific message when the location is permanently denied
        state = state.copyWith(
          isLocationLoading: false,
          message:
              'Location permissions permanently denied, please enable in settings.',
        );
        return;
      }
      // Handles the case when the location permissions have been denied by the user.
      if (permission == geo.LocationPermission.denied) {
         // Updates the state to show the message to the user.
        state = state.copyWith(
          isLocationLoading: false,
          message: 'Location permissions denied, using default location.',
        );
        // Moves the map to the default position
        await map.flyTo(
          CameraOptions(
            center: Point(
              coordinates: Position(
                AppConstants.defaultLongitude,
                AppConstants.defaultLatitude,
              ),
            ),
            zoom: AppConstants.defaultZoom,
          ),
          MapAnimationOptions(duration: 200),
        );

        return;
      }
      // Get's current position with high accuracy using the geolocator plugin.
      final position = await geo.Geolocator.getCurrentPosition(
        desiredAccuracy: geo.LocationAccuracy.high,
      );
      // Moves the map to the user's current location.
      await map.flyTo(
        CameraOptions(
          center: Point(
            coordinates: Position(position.longitude, position.latitude),
          ),
          zoom: AppConstants.defaultZoom,
        ),
        MapAnimationOptions(duration: 200),
      );
    } on Exception catch (e, stackTrace) {
      // Logs the exception to the console in debug mode.
      if (kDebugMode) {
        print('Error getting current location: $e, StackTrace: $stackTrace');
      }
        // Updates the state with the error message when the current location cannot be obtained.
      state = state.copyWith(
        isLocationLoading: false,
        message: 'Error getting current location, using default location.',
      );
        // Moves the map to the default location if there is an error while getting the user location.
      await map.flyTo(
        CameraOptions(
          center: Point(
            coordinates: Position(
              AppConstants.defaultLongitude,
              AppConstants.defaultLatitude,
            ),
          ),
          zoom: AppConstants.defaultZoom,
        ),
        MapAnimationOptions(duration: 200),
      );
       // Finally, update the state to not loading when the operation has finished
    } finally {
      if (mounted) {
        state = state.copyWith(isLocationLoading: false);
      }
    }
  }
}
############## End of /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/lib/features/map/map_viewmodel.dart ##############

############## Begin of /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/lib/features/map/map_screen.dart ##############
///
/// File: lib/features/map/map_screen.dart
/// Author: Adil AJDAA
/// Email: a.ajdaa@outlook.com
/// Purpose: Displays the main map screen, including rendering the map, handling map events, and showing markers.
/// Updates: Initial setup with Mapbox integration, dynamic marker display, and UI controls such as clear, settings, offline and refresh buttons. Also provides support for showing map markers info, zoom in, zoom out and move to the current location
/// Used Libraries: dart/async.dart, dart/typed_data.dart, dart/ui.dart, flutter/foundation.dart, flutter/material.dart, flutter_riverpod/flutter_riverpod.dart, mapbox_maps_flutter/mapbox_maps_flutter.dart, mobile/core/config/app_routes.dart, mobile/core/utils/app_constants.dart, mobile/features/map/map_viewmodel.dart, mobile/shared/models/map_marker.dart, mobile/shared/widgets/custom_error_widget.dart, mobile/shared/widgets/loading_overlay.dart, mobile/shared/widgets/map_controls.dart, mobile/shared/widgets/map_widget.dart, mobile/shared/widgets/offline_banner.dart
///
library;
import 'dart:async';
import 'dart:typed_data';
import 'dart:ui';

import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:mapbox_maps_flutter/mapbox_maps_flutter.dart' as mb;
import 'package:mobile/core/config/app_routes.dart';
import 'package:mobile/core/utils/app_constants.dart';
import 'package:mobile/features/map/map_viewmodel.dart';
import 'package:mobile/shared/models/map_marker.dart' as map_marker;
import 'package:mobile/shared/widgets/custom_error_widget.dart';
import 'package:mobile/shared/widgets/loading_overlay.dart';
import 'package:mobile/shared/widgets/map_controls.dart';
import 'package:mobile/shared/widgets/map_widget.dart' as mapwidget;
import 'package:mobile/shared/widgets/offline_banner.dart';

/// MapScreen displays the main map with markers and provides UI elements for different actions.
class MapScreen extends ConsumerStatefulWidget {
  const MapScreen({super.key});

  @override
  ConsumerState<MapScreen> createState() => _MapScreenState();
}

class _MapScreenState extends ConsumerState<MapScreen> {
   /// Mapbox map object for map interaction
  mb.MapboxMap? _mapboxMap;
   ///  Point annotation manager used for managing markers on the map.
  mb.PointAnnotationManager? _pointAnnotationManager;
   ///  Camera options for setting the initial map view
  late mb.CameraOptions _initialCameraOptions;
   /// Default map style url.
  final String mapStyle = AppConstants.mapboxStreets;
   /// List for managing point annotations for map markers.
  final List<mb.PointAnnotation> _pointAnnotations = [];
    /// Subscription for connectivity changes.
  StreamSubscription<bool>? _connectivitySubscription;
  /// Listener for clicks on map markers
  late final mb.OnPointAnnotationClickListener _pointAnnotationClickListener;
  
  @override
  void initState() {
    super.initState();
    // Sets the default camera options
    _initialCameraOptions = mb.CameraOptions(
      center: mb.Point(
        coordinates: mb.Position(
          AppConstants.defaultLongitude,
          AppConstants.defaultLatitude,
        ),
      ),
      zoom: AppConstants.defaultZoom,
    );
    // Setting up point click listener
    _pointAnnotationClickListener = _PointAnnotationClickListener(this);
  }

  @override
  void dispose() {
      //Cancels the connectivity subscription when the screen is disposed
    _connectivitySubscription?.cancel();
    // _pointAnnotationManager?.removeClickListener(_pointAnnotationClickListener);
    super.dispose();
  }

  @override
  Widget build(BuildContext context) => Scaffold(
      // AppBar of the application
        appBar: AppBar(
          title: const Text('Online Maps'),
           // List of action buttons for the map screen.
          actions: [
            IconButton(
               // Button to clear the map markers.
              icon: const Icon(Icons.clear_all),
              onPressed: () {
                ref.read(mapViewModelProvider.notifier).clearMarkers();
              },
            ),
            IconButton(
              // Button to open the settings screen.
              icon: const Icon(Icons.settings),
              onPressed: () {
                Navigator.of(context).pushNamed(AppRoutes.settings);
              },
            ),
             // Button to open the offline map screen.
            IconButton(
              icon: const Icon(Icons.offline_bolt),
              onPressed: () {
                Navigator.of(context).pushNamed(AppRoutes.offlineMap);
              },
            ),
              // Button to refresh map markers
            IconButton(
              icon: const Icon(Icons.refresh),
              onPressed: () => ref
                  .read(mapViewModelProvider.notifier)
                  .loadMarkers(forceRefresh: true),
            ),
          ],
        ),
        // Main body of the app
        body: Consumer(
          builder: (BuildContext context, WidgetRef ref, Widget? child) {
            final state = ref.watch(mapViewModelProvider);
             // Sets a listener to show a snack bar if a message is added to the state, also updates the markers if a change has occurred
            ref.listen(mapViewModelProvider, (previous, next) {
                // Checks if there is a new message from the state, and if so shows a snack bar
              if (next.message != null && next.message!.isNotEmpty) {
                ScaffoldMessenger.of(context).showSnackBar(
                  SnackBar(content: Text(next.message!)),
                );
              }
                // Check if there are any errors that have been set and shows a snackbar if there is any.
              if (next.error != null && next.error!.isNotEmpty) {
                // ScaffoldMessenger.of(context).showSnackBar(
                //   SnackBar(content: Text(next.error!)),
                // );
              }

              // Add's markers if there has been any changes
              if (previous?.markers != next.markers) {
                _addMarkers();
              }
            });

            return Stack(
              children: [
                 // Map widget to display the map
                mapwidget.CustomMapWidget(
                  styleUri: mapStyle,
                  cameraOptions: _initialCameraOptions,
                  onMapCreated: _onMapCreated,
                ),
                // Shows the banner if the app is offline
                OfflineBanner(
                  isOffline: state.isOffline,
                ),
                 // Displays map controls to zoom in, zoom out and move to the current location.
                MapControls(
                  onZoomIn: _zoomIn,
                  onZoomOut: _zoomOut,
                  onMoveToCurrentLocation: _moveToCurrentLocation,
                  isLocationLoading: state.isLocationLoading,
                ),
                // Custom error widget for displaying errors from the view model.
                if (state.error != null && state.error!.isNotEmpty)
                  CustomErrorWidget(
                    error: state.error!,
                    onClose: () =>
                        ref.read(mapViewModelProvider.notifier).clearMarkers(),
                  ),
                 // Loading overlay for displaying while the markers are loading.
                if (state.isLoading)
                  const LoadingOverlay(message: 'Loading Markers...'),
              ],
            );
          },
        ),
      );

   /// Callback when map has been created, initializes point annotation manager, sets map to view model and adds all markers
  Future<void> _onMapCreated(mb.MapboxMap mapboxMap) async {
    _mapboxMap = mapboxMap;
     // Sets the map instance into the view model.
    ref.read(mapViewModelProvider.notifier).setMap(mapboxMap);
    // Creates the point annotation manager to manage the map markers
    _pointAnnotationManager =
        await mapboxMap.annotations.createPointAnnotationManager();
    // Sets the point annotation click listener
    _pointAnnotationManager
        ?.addOnPointAnnotationClickListener(_pointAnnotationClickListener);
        // Add's the markers to the map.
    await _addMarkers();
  }

    /// Adds the markers to the map, using point annotation manager.
  Future<void> _addMarkers() async {
      // Returns early if the manager is null
    if (_pointAnnotationManager == null || _mapboxMap == null) {
      return;
    }

    final state = ref.read(mapViewModelProvider);

     // Remove all existing annotations before adding new ones.
    if (_pointAnnotations.isNotEmpty) {
      for (final annotation in _pointAnnotations) {
        await _pointAnnotationManager?.delete(annotation);
      }
      _pointAnnotations.clear();
    }

     // Iterates over the markers in the state and adds them to the map
    for (final marker in state.markers) {
      if (marker.geometry.type == map_marker.GeometryType.point) {
         //  Creates an annotation using the given coordinates.
        final annotation = mb.PointAnnotationOptions(
          geometry: mb.Point(
            coordinates: mb.Position(
              marker.geometry.coordinates[0],
              marker.geometry.coordinates[1],
            ),
          ),
          iconImage: 'circle',
          iconColor: Colors.red.r.toInt(),
        );
        // Creates the annotation to the map, using the annotation manager
        final createdAnnotation =
            await _pointAnnotationManager?.create(annotation);
        if (createdAnnotation != null) {
          createdAnnotation.id = marker.id;
          _pointAnnotations.add(createdAnnotation);
        }
      }
    }
       // Adds the custom circle image to the map.
    if (_mapboxMap != null) {
      await addCustomCircleImage();
    }
  }

   /// Adds a custom circle image for the markers, used for map annotation icons.
  Future<void> addCustomCircleImage() async {
    // Create the custom circle image using a helper function.
    final imageBytes = await _createCircleIcon(Colors.red);

    // Create MbxImage from bytes
    final mbxImage = mb.MbxImage(
      width: 20,
      height: 20,
      data: imageBytes,
    );

    // Add style image to the Mapbox style
    await _mapboxMap!.style.addStyleImage(
      'circle',
      1,
      mbxImage,
      false,
      [],
      [],
      null,
    );
  }

   /// Creates a circle icon as a Uint8List, used to display a custom icon on the map.
  Future<Uint8List> _createCircleIcon(Color color) async {
    final recorder = PictureRecorder();
    final canvas = Canvas(recorder);
    final paint = Paint()..color = color;
    const radius = 10.0;
    canvas.drawCircle(const Offset(radius, radius), radius, paint);
    final picture = recorder.endRecording();
    final image = await picture.toImage(radius.toInt() * 2, radius.toInt() * 2);
    final bytes = await image.toByteData(format: ImageByteFormat.png);
    return bytes!.buffer.asUint8List();
  }

   /// Shows information about the selected marker in an alert dialog
  void _showMarkerInfo(BuildContext context, map_marker.MapMarker marker) {
    showDialog(
      context: context,
      builder: (BuildContext context) => AlertDialog(
        title: Text(marker.title),
        content: Text(marker.description),
        actions: <Widget>[
          TextButton(
            child: const Text('Close'),
            onPressed: () {
              Navigator.of(context).pop();
            },
          ),
        ],
      ),
    );
  }

  /// Zooms in on the map using the flyTo method with animation.
  Future<void> _zoomIn() async {
    if (_mapboxMap == null) {
      return;
    }
    final currentZoom =
        await _mapboxMap!.getCameraState().then((value) => value.zoom);
    await _mapboxMap!.flyTo(
      mb.CameraOptions(zoom: currentZoom + 1),
      mb.MapAnimationOptions(duration: 200),
    );
  }

   /// Zooms out on the map using the flyTo method with animation.
  Future<void> _zoomOut() async {
    if (_mapboxMap == null) {
      return;
    }
    final currentZoom =
        await _mapboxMap!.getCameraState().then((value) => value.zoom);
    await _mapboxMap!.flyTo(
      mb.CameraOptions(zoom: currentZoom - 1),
      mb.MapAnimationOptions(duration: 200),
    );
  }

   /// Moves the map to the current device location using the view model
  Future<void> _moveToCurrentLocation() async {
    if (_mapboxMap == null) {
      return;
    }
    await ref
        .read(mapViewModelProvider.notifier)
        .moveToCurrentLocation(_mapboxMap!);
  }
}

/// Listener class for clicks on point annotations, it shows a dialog when clicked.
class _PointAnnotationClickListener extends mb.OnPointAnnotationClickListener {
    ///  Constructor takes the state of the map screen as an argument.
  _PointAnnotationClickListener(this._state);
   /// State of the map screen, allowing the listener to access to the methods and view models of the map screen
  final _MapScreenState _state;
  @override
  void onPointAnnotationClick(mb.PointAnnotation annotation) {
      // Checks if the annotation has an id before showing the marker info.
    if (annotation.id.isNotEmpty) {
       // Get the marker associated to the current annotation, using it's id.
      final marker = _state.ref
          .read(mapViewModelProvider)
          .markers
          .firstWhere((element) => element.id == annotation.id);
          // Shows the marker info in a dialog.
      _state._showMarkerInfo(_state.context, marker);
    }
  }
}
############## End of /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/lib/features/map/map_screen.dart ##############

############## Directory: /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/lib/features/map ##############

############## Directory: /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/lib/shared ##############

############## Begin of /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/lib/shared/models/map_marker.g.dart ##############
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'map_marker.dart';

// **************************************************************************
// TypeAdapterGenerator
// **************************************************************************

class MapMarkerAdapter extends TypeAdapter<MapMarker> {
  @override
  final int typeId = 0;

  @override
  MapMarker read(BinaryReader reader) {
    final numOfFields = reader.readByte();
    final fields = <int, dynamic>{
      for (int i = 0; i < numOfFields; i++) reader.readByte(): reader.read(),
    };
    return MapMarker(
      id: fields[0] as String,
      title: fields[1] as String,
      description: fields[2] as String,
      geometry: fields[3] as Geometry,
    );
  }

  @override
  void write(BinaryWriter writer, MapMarker obj) {
    writer
      ..writeByte(4)
      ..writeByte(0)
      ..write(obj.id)
      ..writeByte(1)
      ..write(obj.title)
      ..writeByte(2)
      ..write(obj.description)
      ..writeByte(3)
      ..write(obj.geometry);
  }

  @override
  int get hashCode => typeId.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is MapMarkerAdapter &&
          runtimeType == other.runtimeType &&
          typeId == other.typeId;
}

class GeometryAdapter extends TypeAdapter<Geometry> {
  @override
  final int typeId = 1;

  @override
  Geometry read(BinaryReader reader) {
    final numOfFields = reader.readByte();
    final fields = <int, dynamic>{
      for (int i = 0; i < numOfFields; i++) reader.readByte(): reader.read(),
    };
    return Geometry(
      type: fields[0] as GeometryType,
      coordinates: (fields[1] as List).cast<dynamic>(),
    );
  }

  @override
  void write(BinaryWriter writer, Geometry obj) {
    writer
      ..writeByte(2)
      ..writeByte(0)
      ..write(obj.type)
      ..writeByte(1)
      ..write(obj.coordinates);
  }

  @override
  int get hashCode => typeId.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is GeometryAdapter &&
          runtimeType == other.runtimeType &&
          typeId == other.typeId;
}

class GeometryTypeAdapter extends TypeAdapter<GeometryType> {
  @override
  final int typeId = 2;

  @override
  GeometryType read(BinaryReader reader) {
    switch (reader.readByte()) {
      case 0:
        return GeometryType.point;
      case 1:
        return GeometryType.lineString;
      case 2:
        return GeometryType.polygon;
      default:
        return GeometryType.point;
    }
  }

  @override
  void write(BinaryWriter writer, GeometryType obj) {
    switch (obj) {
      case GeometryType.point:
        writer.writeByte(0);
        break;
      case GeometryType.lineString:
        writer.writeByte(1);
        break;
      case GeometryType.polygon:
        writer.writeByte(2);
        break;
    }
  }

  @override
  int get hashCode => typeId.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is GeometryTypeAdapter &&
          runtimeType == other.runtimeType &&
          typeId == other.typeId;
}

############## End of /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/lib/shared/models/map_marker.g.dart ##############

############## Begin of /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/lib/shared/models/map_marker.dart ##############
///
/// File: lib/shared/models/map_marker.dart
/// Author: Adil AJDAA
/// Email: a.ajdaa@outlook.com
/// Purpose: Defines the data models for map markers and their geometry, used for handling and storing geospatial data.
/// Updates: Initial setup with MapMarker, Geometry, and GeometryType models for managing geospatial data, added json parsing functionality.
/// Used Libraries: hive/hive.dart
///
library;
import 'package:hive/hive.dart';
part 'map_marker.g.dart';

/// Represents a map marker with an ID, title, description, and geometry.
@HiveType(typeId: 0)
class MapMarker {
   /// Constructor for the MapMarker class, requires `id`, `title`, `description` and `geometry`
  MapMarker({
    required this.id,
    required this.title,
    required this.description,
    required this.geometry,
  });
  /// Validates the JSON data and creates the MapMarker model.
  factory MapMarker._validateAndCreateMapMarker(Map<String, dynamic> json) {
    final String? id = json['id'];
    final String? title = json['title'];
    final String? description = json['description'];
    final dynamic geometry = json['geometry'];
    // Throws errors if the id or title is null or empty.
    if (id == null || id.isEmpty) {
      throw ArgumentError('MapMarker id cannot be null or empty.');
    }
    if (title == null || title.isEmpty) {
      throw ArgumentError('MapMarker title cannot be null or empty.');
    }
      // Throws an error if the description or the geometry is null
    if (description == null) {
      throw ArgumentError('MapMarker description cannot be null.');
    }
    if (geometry == null) {
      throw ArgumentError('MapMarker geometry cannot be null.');
    }
       // Creates and return the new `MapMarker`.
    return MapMarker(
      id: id,
      title: title,
      description: description,
      geometry: Geometry.fromJson(geometry),
    );
  }
   /// Creates a `MapMarker` instance from a JSON object, validates the data and calls the `_validateAndCreateMapMarker` function.
  factory MapMarker.fromJson(Map<String, dynamic> json) =>
      MapMarker._validateAndCreateMapMarker(json);

  /// Unique identifier for the map marker
  @HiveField(0)
  final String id;

  ///  Title of the map marker
  @HiveField(1)
  final String title;

  /// Description of the map marker
  @HiveField(2)
  final String description;

  /// Geometry of the map marker.
  @HiveField(3)
  final Geometry geometry;

   /// Converts MapMarker object to a JSON object
  Map<String, dynamic> toJson() => {
        'id': id,
        'title': title,
        'description': description,
        'geometry': geometry.toJson(),
      };
}

/// Enum representing the type of geometry (point, linestring, polygon).
@HiveType(typeId: 2)
enum GeometryType {
  /// Point geometry type.
  @HiveField(0)
  point,
  /// LineString geometry type.
  @HiveField(1)
  lineString,
  /// Polygon geometry type.
  @HiveField(2)
  polygon
}

/// Represents the geometry of a map marker, can be of type point, linestring or polygon
@HiveType(typeId: 1)
class Geometry {
  /// Constructor for the geometry class, takes the `type` and `coordinates` as a parameter.
  Geometry({
    required this.type,
    required this.coordinates,
  });
  /// Creates a `Geometry` object from JSON data, includes validation for geometry type and coordinates
  factory Geometry.fromJson(Map<String, dynamic> json) {
    final type = json['type'];
    final coordinates = json['coordinates'];
       // Checks if type is null or not string.
    if (type == null || type is! String) {
      throw ArgumentError('Invalid geometry type: $type');
    }
    // Checks if the coordinates is null or not a List.
    if (coordinates == null || coordinates is! List) {
      throw ArgumentError('Invalid geometry coordinates: $coordinates');
    }
        // Parses the coordinates to a GeometryType
    return Geometry(
      type: _parseType(type),
      coordinates: coordinates,
    );
  }
    /// Creates a JSON object from a `Geometry` model
  Map<String, dynamic> toJson() => {
        'type': type.name,
        'coordinates': coordinates,
      };
  /// Parses a geometry type from a string, throws exception when not a valid type.
  static GeometryType _parseType(String type) {
    switch (type) {
      case 'Point':
        return GeometryType.point;
      case 'LineString':
        return GeometryType.lineString;
            case 'Polygon':
        return GeometryType.polygon;
      default:
        throw ArgumentError('Invalid geometry type: $type');
    }
  }

  /// Type of the geometry, it can be `Point`, `LineString` or `Polygon`.
  @HiveField(0)
  late final GeometryType type;
   /// Coordinates of the geometry, it's a list of dynamic values.
  @HiveField(1)
  late final List<dynamic> coordinates;
}
############## End of /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/lib/shared/models/map_marker.dart ##############

############## Directory: /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/lib/shared/models ##############

############## Begin of /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/lib/shared/widgets/theme_picker.dart ##############
///
/// File: lib/shared/widgets/theme_picker.dart
/// Author: Adil AJDAA
/// Email: a.ajdaa@outlook.com
/// Purpose: Displays a theme picker that allows users to select between light and dark themes.
/// Updates: Initial setup with radio buttons for theme selection.
/// Used Libraries: flutter/material.dart, flutter_riverpod/flutter_riverpod.dart, mobile/main.dart
///
library;
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:mobile/main.dart';

/// ThemePicker widget enables users to switch between light and dark themes using radio buttons.
class ThemePicker extends ConsumerWidget {
    /// Constructor for the `ThemePicker` widget, takes `onThemeChanged` callback as a parameter
  const ThemePicker({required this.onThemeChanged, super.key});
   /// Callback function that is called when a theme has changed.
  final Function(ThemeMode) onThemeChanged;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
      // Gets the current selected theme.
    final theme = ref.watch(themeModeProvider);
    return Column(
      children: [
        ListTile(
           // ListTile that shows the label for light theme.
          title: const Text('Light Theme'),
           // Radio button for the light theme.
          trailing: Radio<ThemeMode>(
            value: ThemeMode.light,
            groupValue: theme,
            onChanged: (ThemeMode? value) {
              onThemeChanged(value!);
            },
          ),
        ),
         // ListTile that shows the label for dark theme.
        ListTile(
          title: const Text('Dark Theme'),
            // Radio button for dark theme.
          trailing: Radio<ThemeMode>(
            value: ThemeMode.dark,
            groupValue: theme,
            onChanged: (ThemeMode? value) {
              onThemeChanged(value!);
            },
          ),
        ),
      ],
    );
  }
}
############## End of /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/lib/shared/widgets/theme_picker.dart ##############

############## Begin of /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/lib/shared/widgets/region_item.dart ##############
///
/// File: lib/shared/widgets/region_item.dart
/// Author: Adil AJDAA
/// Email: a.ajdaa@outlook.com
/// Purpose: Displays a single item representing a downloaded map region, including an option to delete it.
/// Updates: Initial setup for listing tile regions with delete capabilities.
/// Used Libraries: flutter/material.dart, mapbox_maps_flutter/mapbox_maps_flutter.dart
///
library;
import 'package:flutter/material.dart';
import 'package:mapbox_maps_flutter/mapbox_maps_flutter.dart';

/// RegionItem widget displays a single downloaded region with a delete button.
class RegionItem extends StatelessWidget {
    /// Constructor for the region item takes `region` and `deleteRegion` callback.
  const RegionItem({
    required this.region,
    required this.deleteRegion,
    super.key,
  });
  /// Tile region for showing details
  final TileRegion region;
   /// Callback for deleting the current region.
  final Function(String) deleteRegion;

  @override
  Widget build(BuildContext context) => ListTile(
        // Region id as the title
        title: Text(region.id),
        // Button to trigger the delete functionality
        trailing: IconButton(
          onPressed: () {
            deleteRegion(region.id);
          },
          icon: const Icon(Icons.delete),
        ),
      );
}
############## End of /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/lib/shared/widgets/region_item.dart ##############

############## Begin of /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/lib/shared/widgets/map_controls.dart ##############
///
/// File: lib/shared/widgets/map_controls.dart
/// Author: Adil AJDAA
/// Email: a.ajdaa@outlook.com
/// Purpose: Displays map controls such as zoom in, zoom out, and move to current location on the map.
/// Updates: Initial setup of map controls with zoom in, zoom out, and current location actions.
/// Used Libraries: flutter/material.dart
///
library;
import 'package:flutter/material.dart';

/// MapControls widget provides the UI controls for map zoom and current location.
class MapControls extends StatelessWidget {
    /// Constructor for the MapControls widget, takes callbacks for zoom in, zoom out and move to current location.
  const MapControls({
    required this.onZoomIn,
    required this.onZoomOut,
    required this.onMoveToCurrentLocation,
    super.key,
    this.isLocationLoading = false,
  });
   /// Callback function called when the zoom in button is clicked.
  final VoidCallback onZoomIn;
    /// Callback function called when the zoom out button is clicked.
  final VoidCallback onZoomOut;
  /// Callback function called when the move to current location button is clicked.
  final VoidCallback onMoveToCurrentLocation;
    /// Location loading state to disable location button and show loader.
  final bool isLocationLoading;

  @override
  Widget build(BuildContext context) => Positioned(
        bottom: 16,
        right: 16,
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
              //  Floating action button for zoom in.
            FloatingActionButton(
              heroTag: 'zoom_in',
              mini: true,
              onPressed: onZoomIn,
              child: const Icon(Icons.add),
            ),
            const SizedBox(height: 8), // space
             //  Floating action button for zoom out.
            FloatingActionButton(
              heroTag: 'zoom_out',
              mini: true,
              onPressed: onZoomOut,
              child: const Icon(Icons.remove),
            ),
            const SizedBox(height: 8),
              //  Floating action button for the move to the current location functionality.
            FloatingActionButton(
              heroTag: 'my_location',
              mini: true,
              onPressed: onMoveToCurrentLocation,
              child: isLocationLoading
                  ? const SizedBox(
                      width: 24,
                      height: 24,
                      child: CircularProgressIndicator(
                        strokeWidth: 2,
                      ),
                    )
                  : const Icon(Icons.my_location),
            ),
          ],
        ),
      );
}
############## End of /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/lib/shared/widgets/map_controls.dart ##############

############## Begin of /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/lib/shared/widgets/map_widget.dart ##############
///
/// File: lib/shared/widgets/map_widget.dart
/// Author: Adil AJDAA
/// Email: a.ajdaa@outlook.com
/// Purpose: Displays the Mapbox map with provided configurations.
/// Updates: Initial setup with Mapbox MapWidget and camera options.
/// Used Libraries: flutter/material.dart, mapbox_maps_flutter/mapbox_maps_flutter.dart
///
library;
import 'package:flutter/material.dart';
import 'package:mapbox_maps_flutter/mapbox_maps_flutter.dart';

/// CustomMapWidget is a wrapper around the Mapbox MapWidget to specify custom configurations.
class CustomMapWidget extends StatelessWidget {
  const CustomMapWidget({
    required this.cameraOptions,
    required this.onMapCreated,
    required this.styleUri,
    super.key,
  });
  /// Camera options for setting the initial map view
  final CameraOptions cameraOptions;
   /// Callback for when the map has been created
  final void Function(MapboxMap) onMapCreated;
   /// Style uri for mapbox map to display
  final String styleUri;

  @override
  Widget build(BuildContext context) => MapWidget(
        styleUri: styleUri,
        cameraOptions: cameraOptions,
        onMapCreated: onMapCreated,
        androidHostingMode: AndroidPlatformViewHostingMode.TLHC_HC,
      );
}
############## End of /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/lib/shared/widgets/map_widget.dart ##############

############## Begin of /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/lib/shared/widgets/loading_overlay.dart ##############
///
/// File: lib/shared/widgets/loading_overlay.dart
/// Author: Adil AJDAA
/// Email: a.ajdaa@outlook.com
/// Purpose: Displays a loading overlay with a progress indicator and optional message, used during long processes.
/// Updates: Initial setup for loading overlay with optional message and cancel option.
/// Used Libraries: flutter/material.dart
///
library;
import 'package:flutter/material.dart';

/// LoadingOverlay widget displays a loading indicator, an optional message, and an optional cancel button.
class LoadingOverlay extends StatelessWidget {
    /// Constructor for the `LoadingOverlay` widget, it takes a message and a cancel callback as optional parameters.
  const LoadingOverlay({super.key, this.message, this.onCancel});
   /// Message to display under the loading indicator.
  final String? message;
    /// Callback when the cancel button is clicked.
  final VoidCallback? onCancel;

  @override
  Widget build(BuildContext context) => Container(
        color: Colors.black54,
        child: Center(
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              //Circular loading indicator with white color.
              const CircularProgressIndicator(
                valueColor: AlwaysStoppedAnimation<Color>(Colors.white),
              ),
                // Shows the message if there is any, otherwise, it's not shown.
              if (message != null)
                Padding(
                  padding: const EdgeInsets.only(top: 16),
                  child: Text(
                    message!,
                    style: const TextStyle(color: Colors.white),
                  ),
                ),
                //Shows the cancel button when the callback is provided.
              if (onCancel != null)
                TextButton(
                  onPressed: onCancel,
                  child: const Text(
                    'Cancel',
                    style: TextStyle(color: Colors.white),
                  ),
                ),
            ],
          ),
        ),
      );
}
############## End of /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/lib/shared/widgets/loading_overlay.dart ##############

############## Begin of /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/lib/shared/widgets/custom_error_widget.dart ##############
///
/// File: lib/shared/widgets/custom_error_widget.dart
/// Author: Adil AJDAA
/// Email: a.ajdaa@outlook.com
/// Purpose: Displays a custom error message widget with a close button.
/// Updates: Initial setup for displaying errors with custom background and text colors.
/// Used Libraries: flutter/material.dart
///
library;
import 'package:flutter/material.dart';

/// CustomErrorWidget displays an error message with a close button and customizable styles.
class CustomErrorWidget extends StatelessWidget {
    /// Constructor for the `CustomErrorWidget`, it takes the error message, background color, text color and a close callback as a parameter.
  const CustomErrorWidget({
    required this.error,
    super.key,
    this.backgroundColor,
    this.textColor,
    this.onClose,
  });
   /// Error message to show in the error widget
  final String error;
    /// Background color for error widget, defaults to red if no color is given.
  final Color? backgroundColor;
    /// Color of the text in the error widget, defaults to red[900] if no color is provided.
  final Color? textColor;
  /// Callback function that's called when the close button is pressed.
  final VoidCallback? onClose;

  @override
  Widget build(BuildContext context) => Positioned(
        bottom: 16,
        left: 16,
        right: 16,
        child: ConstrainedBox(
          constraints: const BoxConstraints(maxHeight: 200),
          child: Material(
            elevation: 4,
            borderRadius: BorderRadius.circular(8),
            color: backgroundColor ?? Colors.red[100],
            child: Padding(
              padding: const EdgeInsets.all(8),
              child: Column(
                mainAxisSize: MainAxisSize.min,
                children: [
                 // SingleChildScrollView to make sure that the text doesn't overflows the available space
                  Expanded(
                    child: SingleChildScrollView(
                      child: Text(
                        error,
                        style: TextStyle(color: textColor ?? Colors.red[900]),
                      ),
                    ),
                  ),
                     // Button to close the error dialog.
                  Align(
                    alignment: Alignment.bottomRight,
                    child: TextButton(
                      onPressed: onClose ?? () => Navigator.of(context).pop(),
                      child: const Text('Close'),
                    ),
                  ),
                ],
              ),
            ),
          ),
        ),
      );
}
############## End of /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/lib/shared/widgets/custom_error_widget.dart ##############

############## Begin of /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/lib/shared/widgets/offline_banner.dart ##############
///
/// File: lib/shared/widgets/offline_banner.dart
/// Author: Adil AJDAA
/// Email: a.ajdaa@outlook.com
/// Purpose: Displays a banner when the application is in offline mode.
/// Updates: Initial setup for displaying the banner when the offline flag is true.
/// Used Libraries: flutter/material.dart
///
library;
import 'package:flutter/material.dart';

/// OfflineBanner widget is displayed when the app is in offline mode.
class OfflineBanner extends StatelessWidget {
    /// Constructor for the `OfflineBanner` widget, takes `isOffline` boolean as a parameter.
  const OfflineBanner({super.key, this.isOffline = false});
    /// Boolean flag to indicate if the application is offline.
  final bool isOffline;
  @override
  Widget build(BuildContext context) => isOffline
      ? Positioned(
          top: 0,
          left: 0,
          right: 0,
          child: Container(
            color: Colors.orange,
            padding: const EdgeInsets.all(8),
            child: const Text(
              'Offline Mode',
              textAlign: TextAlign.center,
              style: TextStyle(
                color: Colors.white,
                fontWeight: FontWeight.bold,
              ),
            ),
          ),
        )
      : const SizedBox();
}
############## End of /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/lib/shared/widgets/offline_banner.dart ##############

############## Directory: /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/lib/shared/widgets ##############

############## Directory: /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/test ##############

############## Directory: /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/test/core ##############

############## Begin of /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/test/core/utils/map_utils_unit_test.dart ##############
// test/core/utils/map_utils_unit_test.dart
import 'package:flutter_test/flutter_test.dart';
import 'package:mapbox_maps_flutter/mapbox_maps_flutter.dart';
import 'package:mobile/core/utils/map_utils.dart';

void main() {
  group('map_utils_unit_test', () {
    test('isPointInBounds true', () {
      final point = Point(coordinates: Position(1, 1));
      final bounds = CoordinateBounds(
        southwest: Point(coordinates: Position(0, 0)),
        northeast: Point(coordinates: Position(2, 2)),
        infiniteBounds: true,
      );
      expect(MapUtils.isPointInBounds(point, bounds), true);
    });
    test('isPointInBounds false', () {
      final point = Point(coordinates: Position(3, 3));
      final bounds = CoordinateBounds(
        southwest: Point(coordinates: Position(0, 0)),
        northeast: Point(coordinates: Position(2, 2)),
        infiniteBounds: true,
      );
      expect(MapUtils.isPointInBounds(point, bounds), false);
    });

    test('calculateDistance', () {
      final point1 = Point(coordinates: Position(0, 0));
      final point2 = Point(coordinates: Position(1, 1));
      final distance = MapUtils.calculateDistance(point1, point2);

      expect(distance, isNonZero);
    });
  });
}

############## End of /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/test/core/utils/map_utils_unit_test.dart ##############

############## Begin of /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/test/core/utils/app_utils_unit_test.dart ##############
// test/core/utils/app_utils_unit_test.dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:mobile/core/utils/app_constants.dart';
import 'package:mobile/core/utils/app_utils.dart';
import 'package:mocktail/mocktail.dart';

class MockStateNotifier<T> extends Mock implements StateNotifier<T> {}

class MockRef<S> extends Mock implements Ref<S> {}

class MockBuildContext extends Mock implements BuildContext {}

void main() {
  group('app_utils_unit_test', () {
    test('formatFileSize', () {
      expect(AppUtils.formatFileSize(0), '0 B');
      expect(AppUtils.formatFileSize(1023), '1023.00 B');
      expect(AppUtils.formatFileSize(1024), '1.00 KB');
      expect(AppUtils.formatFileSize(1500), '1.46 KB');
      expect(AppUtils.formatFileSize(1048576), '1.00 MB');
    });

    test('handleStateError with context', () {
      final mockNotifier = MockStateNotifier<dynamic>();
      final mockRef = MockRef<dynamic>();
      final mockContext = MockBuildContext();
      registerFallbackValue(StateController(DownloadStatus.idle));
      when(() => mockNotifier.mounted).thenReturn(true);
      when(() => mockRef.read(any())).thenReturn(mockContext);
      when(() => ScaffoldMessenger.of(mockContext))
          .thenReturn(ScaffoldMessengerState());
      when(
        () => (mockNotifier.state as dynamic).copyWith(
          downloadStatus: any(named: 'downloadStatus'),
          error: any(named: 'error'),
        ),
      ).thenReturn(StateController(DownloadStatus.idle));
      AppUtils.handleStateError(
        mockNotifier,
        mockRef,
        StateController(DownloadStatus.idle),
        'error',
        'error message',
      );

      verify(
        () => (mockNotifier.state as dynamic).copyWith(
          downloadStatus: any(named: 'downloadStatus'),
          error: any(named: 'error'),
        ),
      ).called(1);
      verify(() => mockRef.read(any())).called(1);
    });
    test('handleStateError no context', () {
      final mockNotifier = MockStateNotifier<dynamic>();
      final mockRef = MockRef<dynamic>();
      registerFallbackValue(StateController(DownloadStatus.idle));

      when(() => mockNotifier.mounted).thenReturn(true);
      when(() => mockRef.read(any())).thenReturn(null);
      when(
        () => (mockNotifier.state as dynamic).copyWith(
          downloadStatus: any(named: 'downloadStatus'),
          error: any(named: 'error'),
        ),
      ).thenReturn(StateController(DownloadStatus.idle));
      AppUtils.handleStateError(
        mockNotifier,
        mockRef,
        StateController(DownloadStatus.idle),
        'error',
        'error message',
      );

      verify(
        () => (mockNotifier.state as dynamic).copyWith(
          downloadStatus: any(named: 'downloadStatus'),
          error: any(named: 'error'),
        ),
      ).called(1);
      verifyNever(() => mockRef.read(any()));
    });
    test('handleStateError not mounted', () {
      final mockNotifier = MockStateNotifier<dynamic>();
      final mockRef = MockRef<dynamic>();
      registerFallbackValue(StateController(DownloadStatus.idle));

      when(() => mockNotifier.mounted).thenReturn(false);
      AppUtils.handleStateError(
        mockNotifier,
        mockRef,
        StateController(DownloadStatus.idle),
        'error',
        'error message',
      );
      verifyNever(
        () => (mockNotifier.state as dynamic).copyWith(
          downloadStatus: any(named: 'downloadStatus'),
          error: any(named: 'error'),
        ),
      );
      verifyNever(() => mockRef.read(any()));
    });
  });
}

############## End of /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/test/core/utils/app_utils_unit_test.dart ##############

############## Begin of /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/test/core/utils/error_manager_unit_test.dart ##############
// test/core/utils/error_manager_unit_test.dart
import 'package:flutter_test/flutter_test.dart';
import 'package:mobile/core/utils/error_manager.dart';

void main() {
  group('error_manager_unit_test', () {
    test('setError', () {
      final errorNotifier = ErrorNotifier();
      errorNotifier.setError('test error');
      expect(errorNotifier.mapState.message, 'test error');
    });

    test('clearError', () {
      final errorNotifier = ErrorNotifier();
      errorNotifier.setError('test error');
      errorNotifier.clearError();
      expect(errorNotifier.mapState.message, null);
    });
    test('copyWith', () {
      final errorState = ErrorState(message: 'test error');
      final newState = errorState.copyWith(message: 'new error');
      expect(newState.message, 'new error');
      final newStateNull = errorState.copyWith();
      expect(newStateNull.message, 'test error');
    });
  });
}

############## End of /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/test/core/utils/error_manager_unit_test.dart ##############

############## Directory: /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/test/core/utils ##############

############## Begin of /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/test/core/performance/app_resource_optimizer_unit_test.dart ##############
// test/core/performance/app_resource_optimizer_unit_test.dart
import 'package:flutter/foundation.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:mobile/core/performance/app_resource_optimizer.dart';

void main() {
  group('app_resource_optimizer_unit_test', () {
    test('compressImage returns null for empty list', () async {
      final result = await AppResourceOptimizer.compressImage(Uint8List(0));
      expect(result, null);
    });
    test('clearTempFiles success', () async {
      // Test not possible because of dependency on getTempDirectory
    });
  });
}

############## End of /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/test/core/performance/app_resource_optimizer_unit_test.dart ##############

############## Begin of /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/test/core/performance/performance_monitor_unit_test.dart ##############
// test/core/performance/performance_monitor_unit_test.dart
import 'package:flutter_test/flutter_test.dart';
import 'package:mobile/core/performance/performance_monitor.dart';

void main() {
  group('performance_monitor_unit_test', () {
    test('startMonitoring and stopMonitoring', () {
      PerformanceMonitor.startMonitoring();
      expect(PerformanceMonitor.isMonitoring, true);
      PerformanceMonitor.stopMonitoring();
      expect(PerformanceMonitor.isMonitoring, false);
    });
  });
}

############## End of /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/test/core/performance/performance_monitor_unit_test.dart ##############

############## Directory: /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/test/core/performance ##############

############## Begin of /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/test/core/services/permission_service_unit_test.dart ##############
// test/core/services/permission_service_unit_test.dart
import 'package:flutter_test/flutter_test.dart';
import 'package:geolocator/geolocator.dart' as geo;
import 'package:mobile/core/services/permission_service.dart';
import 'package:mocktail/mocktail.dart';
import 'package:permission_handler/permission_handler.dart';

class MockPermission extends Mock implements Permission {}

class MockGeolocator extends Mock implements geo.Geolocator {}

void main() {
  group('permission_service_unit_test', () {
    late MockPermission mockPermission;
    late MockGeolocator mockGeolocator;

    setUp(() {
      mockPermission = MockPermission();
      mockGeolocator = MockGeolocator();
    });
    test('requestNotificationPermissions granted', () async {
      when(() => mockPermission.request())
          .thenAnswer((_) async => PermissionStatus.granted);
      when(() => Permission.notification).thenReturn(mockPermission);

      await PermissionService.requestNotificationPermissions();
      verify(() => mockPermission.request()).called(1);
    });

    test('requestNotificationPermissions denied', () async {
      when(() => mockPermission.request())
          .thenAnswer((_) async => PermissionStatus.denied);
      when(() => Permission.notification).thenReturn(mockPermission);

      await PermissionService.requestNotificationPermissions();
      verify(() => mockPermission.request()).called(1);
    });

    test('requestNotificationPermissions permanentlyDenied', () async {
      when(() => mockPermission.request())
          .thenAnswer((_) async => PermissionStatus.permanentlyDenied);
      when(() => Permission.notification).thenReturn(mockPermission);
      when(openAppSettings).thenAnswer((_) async => true);
      await PermissionService.requestNotificationPermissions();
      verify(() => mockPermission.request()).called(1);
      verify(openAppSettings).called(1);
    });
    test('requestLocationPermissions whileInUse', () async {
      when(geo.Geolocator.requestPermission)
          .thenAnswer((_) async => geo.LocationPermission.whileInUse);

      final result = await PermissionService.requestLocationPermissions();

      expect(result, geo.LocationPermission.whileInUse);
    });

    test('requestLocationPermissions always', () async {
      when(geo.Geolocator.requestPermission)
          .thenAnswer((_) async => geo.LocationPermission.always);

      final result = await PermissionService.requestLocationPermissions();

      expect(result, geo.LocationPermission.always);
    });
    test('requestLocationPermissions denied', () async {
      when(geo.Geolocator.requestPermission)
          .thenAnswer((_) async => geo.LocationPermission.denied);

      final result = await PermissionService.requestLocationPermissions();
      expect(result, geo.LocationPermission.denied);
    });
    test('requestLocationPermissions permanentlyDenied', () async {
      when(geo.Geolocator.requestPermission)
          .thenAnswer((_) async => geo.LocationPermission.deniedForever);
      when(geo.Geolocator.openAppSettings).thenAnswer((_) async => true);
      final result = await PermissionService.requestLocationPermissions();
      expect(result, geo.LocationPermission.deniedForever);
      verify(geo.Geolocator.openAppSettings).called(1);
    });
  });
}

############## End of /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/test/core/services/permission_service_unit_test.dart ##############

############## Begin of /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/test/core/services/tile_service_unit_test.dart ##############
// test/core/services/tile_service_unit_test.dart
import 'package:flutter_test/flutter_test.dart';
import 'package:mapbox_maps_flutter/mapbox_maps_flutter.dart';
import 'package:mobile/core/services/tile_service.dart';

void main() {
  group('tile_service_unit_test', () {
    late TileService tileService;

    setUp(() async {
      tileService = TileService();
      await tileService.initialize();
    });
    test('initialize success', () async {});
    test('downloadTiles success', () async {
      final bounds = CoordinateBounds(
        southwest: Point(coordinates: Position(0, 0)),
        northeast: Point(coordinates: Position(1, 1)),
        infiniteBounds: false,
      );
      await tileService.downloadTiles(bounds, 1, 5, 'test');
    });

    test('removeTileRegion success', () async {
      await tileService.removeTileRegion('test');
    });

    test('getTileRegion success', () async {
      final region = TileRegion(
        id: 'test',
        completedResourceSize: 10,
        completedResourceCount: 10,
        requiredResourceCount: 10,
      );
      final result = await tileService.getTileRegion('test');
      expect(result, region);
    });

    test('getAllTileRegions success', () async {
      final region = TileRegion(
        id: 'test',
        completedResourceSize: 10,
        completedResourceCount: 10,
        requiredResourceCount: 10,
      );

      final result = await tileService.getAllTileRegions();
      expect(result, [region]);
    });
    test('isRegionDownloaded true', () async {
      final bounds = CoordinateBounds(
        southwest: Point(coordinates: Position(0, 0)),
        northeast: Point(coordinates: Position(1, 1)),
        infiniteBounds: false,
      );

      final region = TileRegion(
        id: '0,0-1,1',
        completedResourceSize: 10,
        completedResourceCount: 10,
        requiredResourceCount: 10,
      );

      final result = await tileService.isRegionDownloaded(bounds);
      expect(result, true);
    });
    test('isRegionDownloaded false', () async {
      final bounds = CoordinateBounds(
        southwest: Point(coordinates: Position(0, 0)),
        northeast: Point(coordinates: Position(1, 1)),
        infiniteBounds: false,
      );

      final result = await tileService.isRegionDownloaded(bounds);
      expect(result, false);
    });
  });
}

############## End of /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/test/core/services/tile_service_unit_test.dart ##############

############## Begin of /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/test/core/services/cache_service_unit_test.dart ##############
// test/core/services/cache_service_unit_test.dart
import 'package:flutter_test/flutter_test.dart';
import 'package:mobile/core/services/cache_service.dart';
import 'package:mobile/core/services/map_service.dart';
import 'package:mobile/core/services/storage_service.dart';
import 'package:mobile/core/services/tile_service.dart';
import 'package:mocktail/mocktail.dart';

class MockStorage extends Mock implements Storage {}

class MockMapService extends Mock implements MapService {}

class MockTileService extends Mock implements TileService {}

void main() {
  group('cache_service_unit_test', () {
    late CacheService cacheService;
    late MockStorage mockStorage;
    late MockMapService mockMapService;
    late MockTileService mockTileService;

    setUp(() {
      mockStorage = MockStorage();
      mockMapService = MockMapService();
      mockTileService = MockTileService();
      cacheService = CacheService(mockStorage, mockMapService, mockTileService);
    });

    test('clearCache success', () async {
      when(() => mockMapService.removeAllTileRegions())
          .thenAnswer((_) async {});
      when(() => mockTileService.clearOldTiles()).thenAnswer((_) async {});
      when(() => mockStorage.clearAll()).thenAnswer((_) async {});

      await cacheService.clearCache();

      verify(() => mockMapService.removeAllTileRegions()).called(1);
      verify(() => mockTileService.clearOldTiles()).called(1);
      verify(() => mockStorage.clearAll()).called(1);
    });
  });
}

############## End of /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/test/core/services/cache_service_unit_test.dart ##############

############## Begin of /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/test/core/services/network_service_unit_test.dart ##############
// test/core/services/network_service_unit_test.dart
import 'package:dio/dio.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:mobile/core/services/network_service.dart';
import 'package:mocktail/mocktail.dart';

class MockDio extends Mock implements Dio {}

void main() {
  group('network_service_unit_test', () {
    late NetworkService networkService;
    late MockDio mockDio;

    setUp(() {
      mockDio = MockDio();
      networkService = NetworkService();
      // Replace the _dio instance with mockDio
    });

    test('get success', () async {
      when(() => mockDio.get(any())).thenAnswer(
        (_) async => Response(
          requestOptions: RequestOptions(),
          data: {'test': 'data'},
          statusCode: 200,
        ),
      );

      final response = await networkService.get('/test');
      expect(response.statusCode, 200);
      expect(response.data, {'test': 'data'});
    });

    test('get failure', () async {
      when(() => mockDio.get(any())).thenThrow(
        DioException(
          requestOptions: RequestOptions(),
          type: DioExceptionType.badResponse,
          response: Response(requestOptions: RequestOptions(), statusCode: 404),
        ),
      );

      expect(
        () async => networkService.get('/test'),
        throwsA(isA<DioException>()),
      );
    });
    test('post success', () async {
      when(() => mockDio.post(any(), data: any(named: 'data'))).thenAnswer(
        (_) async => Response(
          requestOptions: RequestOptions(),
          data: {'test': 'data'},
          statusCode: 201,
        ),
      );
      final response = await networkService.post('/test', {'test': 'data'});
      expect(response.statusCode, 201);
      expect(response.data, {'test': 'data'});
    });
    test('post failure', () async {
      when(() => mockDio.post(any(), data: any(named: 'data'))).thenThrow(
        DioException(
          requestOptions: RequestOptions(),
          type: DioExceptionType.badResponse,
          response: Response(requestOptions: RequestOptions(), statusCode: 400),
        ),
      );
      expect(
        () async => networkService.post('/test', {'test': 'data'}),
        throwsA(isA<DioException>()),
      );
    });
    test('put success', () async {
      when(() => mockDio.put(any(), data: any(named: 'data'))).thenAnswer(
        (_) async => Response(
          requestOptions: RequestOptions(),
          data: {'test': 'data'},
          statusCode: 200,
        ),
      );

      final response = await networkService.put('/test', {'test': 'data'});
      expect(response.statusCode, 200);
      expect(response.data, {'test': 'data'});
    });
    test('put failure', () async {
      when(() => mockDio.put(any(), data: any(named: 'data'))).thenThrow(
        DioException(
          requestOptions: RequestOptions(),
          type: DioExceptionType.badResponse,
          response: Response(requestOptions: RequestOptions(), statusCode: 404),
        ),
      );
      expect(
        () async => networkService.put('/test', {'test': 'data'}),
        throwsA(isA<DioException>()),
      );
    });
    test('delete success', () async {
      when(() => mockDio.delete(any())).thenAnswer(
        (_) async =>
            Response(requestOptions: RequestOptions(), statusCode: 204),
      );
      final response = await networkService.delete('/test');
      expect(response.statusCode, 204);
    });
    test('delete failure', () async {
      when(() => mockDio.delete(any())).thenThrow(
        DioException(
          requestOptions: RequestOptions(),
          type: DioExceptionType.badResponse,
          response: Response(requestOptions: RequestOptions(), statusCode: 400),
        ),
      );
      expect(
        () async => networkService.delete('/test'),
        throwsA(isA<DioException>()),
      );
    });
  });
}

############## End of /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/test/core/services/network_service_unit_test.dart ##############

############## Begin of /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/test/core/services/notification_service_unit_test.dart ##############
// test/core/services/notification_service_unit_test.dart
import 'package:flutter_local_notifications/flutter_local_notifications.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:mobile/core/services/notification_service.dart';
import 'package:mocktail/mocktail.dart';

class MockFlutterLocalNotificationsPlugin extends Mock
    implements FlutterLocalNotificationsPlugin {}

void main() {
  group('notification_service_unit_test', () {
    late NotificationService notificationService;
    late MockFlutterLocalNotificationsPlugin mockPlugin;

    setUp(() async {
      mockPlugin = MockFlutterLocalNotificationsPlugin();
      when(
        () => mockPlugin.initialize(
          any(),
          onDidReceiveNotificationResponse:
              any(named: 'onDidReceiveNotificationResponse'),
        ),
      ).thenAnswer((_) async => true);
      notificationService = NotificationService();

      await NotificationService.init();
    });
    test('init success', () async {
      verify(
        () => mockPlugin.initialize(
          any(),
          onDidReceiveNotificationResponse:
              any(named: 'onDidReceiveNotificationResponse'),
        ),
      ).called(1);
    });

    test('showNotification success', () async {
      when(() => mockPlugin.show(any(), any(), any(), any()))
          .thenAnswer((_) async {});
      await NotificationService.showNotification(title: 'test', body: 'test');
      verify(() => mockPlugin.show(any(), any(), any(), any())).called(1);
    });
    test('showProgressNotification success', () async {
      when(() => mockPlugin.show(any(), any(), any(), any()))
          .thenAnswer((_) async {});

      await NotificationService.showProgressNotification(
        title: 'test',
        progress: 50,
      );

      verify(() => mockPlugin.show(any(), any(), any(), any())).called(1);
    });
    test('cancelNotification success', () async {
      when(() => mockPlugin.cancel(any())).thenAnswer((_) async {});

      await NotificationService.cancelNotification(1);
      verify(() => mockPlugin.cancel(any())).called(1);
    });
  });
}

############## End of /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/test/core/services/notification_service_unit_test.dart ##############

############## Begin of /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/test/core/services/map_service_unit_test.dart ##############
// test/core/services/map_service_unit_test.dart
import 'package:flutter_test/flutter_test.dart';
import 'package:mapbox_maps_flutter/mapbox_maps_flutter.dart';
import 'package:mobile/core/services/map_service.dart';
import 'package:mobile/core/services/tile_service.dart';
import 'package:mocktail/mocktail.dart';

class MockTileService extends Mock implements TileService {}

void main() {
  group('map_service_unit_test', () {
    late MapService mapService;
    late MockTileService mockTileService;

    setUp(() async {
      mockTileService = MockTileService();

      mapService = MapService(mockTileService);

      await mapService.init();
    });
    test('init success', () async {});
    test('downloadRegion success', () async {
      final bounds = CoordinateBounds(
        southwest: Point(coordinates: Position(0, 0)),
        northeast: Point(coordinates: Position(1, 1)),
        infiniteBounds: true,
      );

      await mapService.downloadRegion(
        regionName: 'test',
        bounds: bounds,
        onProgress: (progress) {},
        onComplete: () {},
        onError: (e) {},
      );
    });

    test('removeTileRegionAndStylePack success', () async {
      final region = TileRegion(
        id: 'test',
        completedResourceSize: 10,
        completedResourceCount: 10,
        requiredResourceCount: 10,
      );

      when(() => mockTileService.getTileRegion(any()))
          .thenAnswer((_) async => region);
      when(() => mockTileService.removeTileRegion(any()))
          .thenAnswer((_) async {});

      await mapService.removeTileRegionAndStylePack('test', 'test');
      verify(() => mockTileService.removeTileRegion(any())).called(1);
    });
    test('removeAllTileRegions success', () async {
      final region = TileRegion(
        id: 'test',
        completedResourceSize: 10,
        completedResourceCount: 10,
        requiredResourceCount: 10,
      );

      when(() => mockTileService.getAllTileRegions())
          .thenAnswer((_) async => [region]);
      when(() => mockTileService.getTileRegion(any()))
          .thenAnswer((_) async => region);

      when(() => mockTileService.removeTileRegion(any()))
          .thenAnswer((_) async {});
      await mapService.removeAllTileRegions();

      verify(() => mockTileService.removeTileRegion(any())).called(1);
    });
  });
}

############## End of /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/test/core/services/map_service_unit_test.dart ##############

############## Begin of /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/test/core/services/storage_service_unit_test.dart ##############
// test/core/services/storage_service_unit_test.dart
import 'package:flutter_test/flutter_test.dart';
import 'package:hive/hive.dart';
import 'package:mobile/core/services/storage_service.dart';
import 'package:mobile/shared/models/map_marker.dart';
import 'package:mocktail/mocktail.dart';
import 'package:shared_preferences/shared_preferences.dart';

class MockBox<T> extends Mock implements Box<T> {}

class MockSharedPreferences extends Mock implements SharedPreferences {}

void main() {
  TestWidgetsFlutterBinding.ensureInitialized();
  group('storage_service_unit_test', () {
    late Storage storage;
    late MockBox<MapMarker> mockMarkerBox;
    late MockSharedPreferences mockPrefs;
    setUp(() async {
      mockMarkerBox = MockBox<MapMarker>();
      mockPrefs = MockSharedPreferences();
      // Register mock Hive and SharedPreferences
      registerFallbackValue(
        MapMarker(
          id: 'test',
          title: 'test',
          description: 'test',
          geometry: Geometry(type: GeometryType.point, coordinates: [0.0, 0.0]),
        ),
      );

      // when(() => Hive.openBox<MapMarker>(any())).thenAnswer((_) async => mockMarkerBox);
      when(SharedPreferences.getInstance).thenAnswer((_) async => mockPrefs);

      storage = await Storage.init();
    });
    test('saveMarkers success', () async {
      final markers = [
        MapMarker(
          id: '1',
          title: 'test1',
          description: 'test1',
          geometry: Geometry(type: GeometryType.point, coordinates: [0.0, 0.0]),
        ),
        MapMarker(
          id: '2',
          title: 'test2',
          description: 'test2',
          geometry: Geometry(type: GeometryType.point, coordinates: [1.0, 1.0]),
        ),
      ];
      when(() => mockMarkerBox.clear()).thenAnswer((_) async => null);
      when(() => mockMarkerBox.putAll(any())).thenAnswer((_) async {});
      when(() => mockPrefs.setInt(any(), any())).thenAnswer((_) async => true);
      await storage.saveMarkers(markers);

      verify(() => mockMarkerBox.clear()).called(1);
      verify(() => mockMarkerBox.putAll(any())).called(1);
      verify(() => mockPrefs.setInt(any(), any())).called(1);
    });
    test('getMarkers success', () async {
      final markers = [
        MapMarker(
          id: '1',
          title: 'test1',
          description: 'test1',
          geometry: Geometry(type: GeometryType.point, coordinates: [0.0, 0.0]),
        ),
        MapMarker(
          id: '2',
          title: 'test2',
          description: 'test2',
          geometry: Geometry(type: GeometryType.point, coordinates: [1.0, 1.0]),
        ),
      ];
      when(() => mockMarkerBox.values).thenReturn(markers);

      final result = await storage.getMarkers();
      expect(result, markers);
    });
    test('saveInt success', () async {
      when(() => mockPrefs.setInt(any(), any())).thenAnswer((_) async => true);
      await storage.saveInt('test', 1);

      verify(() => mockPrefs.setInt('test', 1)).called(1);
    });
    test('getInt success', () async {
      when(() => mockPrefs.getInt(any())).thenAnswer((_) async => 1);
      final result = await storage.getInt('test');
      expect(result, 1);
    });
    test('saveString success', () async {
      when(() => mockPrefs.setString(any(), any()))
          .thenAnswer((_) async => true);
      await storage.saveString('test', 'test');

      verify(() => mockPrefs.setString('test', 'test')).called(1);
    });
    test('getString success', () async {
      when(() => mockPrefs.getString(any())).thenAnswer((_) async => 'test');
      final result = await storage.getString('test');
      expect(result, 'test');
    });
    test('saveBool success', () async {
      when(() => mockPrefs.setBool(any(), any())).thenAnswer((_) async => true);
      await storage.saveBool('test', value: true);

      verify(() => mockPrefs.setBool('test', true)).called(1);
    });
    test('getBool success', () async {
      when(() => mockPrefs.getBool(any())).thenAnswer((_) async => true);
      final result = await storage.getBool('test');
      expect(result, true);
    });
    test('clearAll success', () async {
      when(() => mockMarkerBox.clear()).thenAnswer((_) async => null);
      when(() => mockPrefs.clear()).thenAnswer((_) async => true);
      await storage.clearAll();
      verify(() => mockMarkerBox.clear()).called(1);
      verify(() => mockPrefs.clear()).called(1);
    });
  });
}

############## End of /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/test/core/services/storage_service_unit_test.dart ##############

############## Directory: /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/test/core/services ##############

############## Begin of /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/test/integration/core_integration_test.dart ##############
// test/integration/core_integration_test.dart
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:mobile/core/config/app_config.dart';
import 'package:mobile/core/services/cache_service.dart';
import 'package:mobile/core/services/map_service.dart';
import 'package:mobile/core/services/network_service.dart';
import 'package:mobile/core/services/storage_service.dart';
import 'package:mobile/core/services/tile_service.dart';

void main() {
  group('core_integration_test', () {
    test('network, storage, and tile services initialization', () async {
      final container = ProviderContainer();
      await container.read(storageProvider.future);
      final networkService = container.read(networkServiceProvider);
      final tileService = container.read(tileServiceProvider);
      final mapService = container.read(mapServiceProvider);
      final cacheService = container.read(cacheManagerProvider);
      expect(networkService, isA<NetworkService>());
      expect(tileService, isA<TileService>());
      expect(mapService, isA<MapService>());
      expect(cacheService, isA<CacheService>());

      container.dispose();
    });
    test('check app config', () async {
      expect(AppConfig.mapboxAccessToken, isNotEmpty);
    });
  });
}

############## End of /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/test/integration/core_integration_test.dart ##############

############## Begin of /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/test/integration/map_integration_test.dart ##############
// test/integration/map_integration_test.dart
import 'package:dartz/dartz.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:mobile/core/services/map_service.dart';
import 'package:mobile/core/services/storage_service.dart';
import 'package:mobile/core/services/tile_service.dart';
import 'package:mobile/features/map/map_repository.dart';
import 'package:mobile/shared/models/map_marker.dart';

void main() {
  group('map_integration_test', () {
    test('map repository can fetch markers', () async {
      final container = ProviderContainer();
      await container.read(storageProvider.future);
      final mapRepository = container.read(mapRepositoryProvider);
      final result = await mapRepository.getMarkers();
      expect(result, isA<Right<MapRepositoryException, List<MapMarker>>>());
      container.dispose();
    });
    test('map service can be initialized', () async {
      final container = ProviderContainer();
      await container.read(storageProvider.future);
      final mapService = container.read(mapServiceProvider);
      expect(mapService, isA<MapService>());
      container.dispose();
    });

    test('tile service can be initialized', () async {
      final container = ProviderContainer();
      final tileService = container.read(tileServiceProvider);
      expect(tileService, isA<TileService>());
      container.dispose();
    });
  });
}

############## End of /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/test/integration/map_integration_test.dart ##############

############## Directory: /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/test/integration ##############

############## Directory: /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/test/features ##############

############## Begin of /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/test/features/settings/settings_screen_widget_test.dart ##############
// test/features/settings/settings_screen_widget_test.dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:mobile/features/settings/settings_screen.dart';
import 'package:mocktail/mocktail.dart';

class MockNavigatorObserver extends Mock implements NavigatorObserver {}

void main() {
  group('settings_screen_widget_test', () {
    testWidgets('settings screen renders', (WidgetTester tester) async {
      final mockObserver = MockNavigatorObserver();
      await tester.pumpWidget(
        ProviderScope(
          child: MaterialApp(
            home: const SettingsScreen(),
            navigatorObservers: [mockObserver],
          ),
        ),
      );
      expect(find.byType(SettingsScreen), findsOneWidget);
    });
    //TODO: add widget test for theme change
    // TODO: Add widget test for clear cache function
    //  testWidgets('theme change works', (WidgetTester tester) async {
    //       final mockObserver = MockNavigatorObserver();
    //   await tester.pumpWidget(
    //      ProviderScope(
    //         child: MaterialApp(
    //           home: const SettingsScreen(),
    //          navigatorObservers: [mockObserver],
    //         ),
    //       ),
    //     );
    //      await tester.tap(find.text('Dark Theme'));
    //       //TODO: add assertion that theme has changed
    //   });
  });
}

############## End of /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/test/features/settings/settings_screen_widget_test.dart ##############

############## Begin of /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/test/features/settings/settings_viewmodel_unit_test.dart ##############
// test/features/settings/settings_viewmodel_unit_test.dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:mobile/core/services/storage_service.dart';
import 'package:mobile/core/services/tile_service.dart';
import 'package:mobile/features/settings/settings_repository.dart';
import 'package:mobile/features/settings/settings_viewmodel.dart';
import 'package:mocktail/mocktail.dart';

import '../../core/utils/app_utils_unit_test.dart';

class MockSettingsRepository extends Mock implements SettingsRepository {}

class MockTileService extends Mock implements TileService {}

class MockStorage extends Mock implements Storage {}

class MockStateController extends Mock implements StateController<ThemeMode> {}

class MockRef extends Mock implements Ref<SettingsState> {}

void main() {
  group('settings_viewmodel_unit_test', () {
    late SettingsViewModel settingsViewModel;
    late MockSettingsRepository mockSettingsRepository;
    late MockTileService mockTileService;
    late MockStorage mockStorage;
    late MockStateController mockThemeModeController;
    late MockRef mockRef;
    setUp(() {
      mockSettingsRepository = MockSettingsRepository();
      mockTileService = MockTileService();
      mockStorage = MockStorage();
      mockThemeModeController = MockStateController();
      mockRef = MockRef<SettingsState>();

      when(() => mockStorage.saveString(any(), any())).thenAnswer((_) async {});
      settingsViewModel = SettingsViewModel(
        mockSettingsRepository,
        mockTileService,
        Future.value(mockStorage),
        mockThemeModeController,
        mockRef,
      );
      registerFallbackValue(SettingsState());
    });
    test('changeTheme success', () async {
      when(() => mockThemeModeController.state = any()).thenAnswer((_) {});

      await settingsViewModel.changeTheme(ThemeMode.dark);
      verify(() => mockStorage.saveString(any(), any())).called(1);
      expect(settingsViewModel.state.themeMode, ThemeMode.dark);
    });

    test('loadRegions success', () async {
      when(() => mockSettingsRepository.getDownloadedRegions())
          .thenAnswer((_) async => ['test']);
      await settingsViewModel.loadRegions();
      expect(settingsViewModel.state.regions, ['test']);
    });

    test('loadRegions failure', () async {
      when(() => mockSettingsRepository.getDownloadedRegions())
          .thenThrow(Exception('test'));
      expect(
        () async => settingsViewModel.loadRegions(),
        throwsA(isA<SettingsViewModelException>()),
      );
    });
    test('clearData success', () async {
      when(() => mockSettingsRepository.clearCache()).thenAnswer((_) async {});
      when(() => mockSettingsRepository.getDownloadedRegions())
          .thenAnswer((_) async => []);
      await settingsViewModel.clearData(MockBuildContext());
      expect(settingsViewModel.state.isLoading, false);
    });
    test('clearData failure', () async {
      when(() => mockSettingsRepository.clearCache())
          .thenThrow(Exception('test'));
      expect(
        () async => settingsViewModel.clearData(MockBuildContext()),
        throwsA(isA<SettingsViewModelException>()),
      );
    });
    test('deleteRegion success', () async {
      when(() => mockSettingsRepository.deleteRegion(any()))
          .thenAnswer((_) async {});
      when(() => mockSettingsRepository.getDownloadedRegions())
          .thenAnswer((_) async => []);

      await settingsViewModel.deleteRegion('test');

      verify(() => mockSettingsRepository.deleteRegion(any())).called(1);
    });
    test('deleteRegion failure', () async {
      when(() => mockSettingsRepository.deleteRegion(any()))
          .thenThrow(Exception('test'));
      expect(
        () async => settingsViewModel.deleteRegion('test'),
        throwsA(isA<SettingsViewModelException>()),
      );
    });
  });
}

############## End of /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/test/features/settings/settings_viewmodel_unit_test.dart ##############

############## Begin of /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/test/features/settings/settings_repository_unit_test.dart ##############
// test/features/settings/settings_repository_unit_test.dart
import 'package:flutter_test/flutter_test.dart';
import 'package:mapbox_maps_flutter/mapbox_maps_flutter.dart';
import 'package:mobile/core/services/cache_service.dart';
import 'package:mobile/core/services/tile_service.dart';
import 'package:mobile/features/settings/settings_repository.dart';
import 'package:mocktail/mocktail.dart';

class MockCacheService extends Mock implements CacheService {}

class MockTileService extends Mock implements TileService {}

void main() {
  group('settings_repository_unit_test', () {
    late SettingsRepository settingsRepository;
    late MockCacheService mockCacheService;
    late MockTileService mockTileService;

    setUp(() {
      mockCacheService = MockCacheService();
      mockTileService = MockTileService();
      settingsRepository =
          SettingsRepository(mockCacheService, mockTileService);
    });

    test('clearCache success', () async {
      when(() => mockCacheService.clearCache()).thenAnswer((_) async {});

      await settingsRepository.clearCache();
      verify(() => mockCacheService.clearCache()).called(1);
    });
    test('getDownloadedRegions success', () async {
      final region = TileRegion(
        id: '0,0-1,1',
        completedResourceSize: 10,
        completedResourceCount: 10,
        requiredResourceCount: 10,
      );

      when(() => mockTileService.tileStore?.allTileRegions())
          .thenAnswer((_) async => [region]);
      final result = await settingsRepository.getDownloadedRegions();
      expect(result, ['test']);
    });
    test('getDownloadedRegions no regions', () async {
      when(() => mockTileService.tileStore?.allTileRegions())
          .thenAnswer((_) async => null);

      final result = await settingsRepository.getDownloadedRegions();
      expect(result, []);
    });
    test('deleteRegion success', () async {
      when(() => mockTileService.removeTileRegion(any()))
          .thenAnswer((_) async {});

      await settingsRepository.deleteRegion('test');
      verify(() => mockTileService.removeTileRegion(any())).called(1);
    });
  });
}

############## End of /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/test/features/settings/settings_repository_unit_test.dart ##############

############## Directory: /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/test/features/settings ##############

############## Begin of /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/test/features/offline_map/offline_map_repository_unit_test.dart ##############
// test/features/offline_map/offline_map_repository_unit_test.dart
import 'package:flutter_test/flutter_test.dart';
import 'package:mapbox_maps_flutter/mapbox_maps_flutter.dart';
import 'package:mobile/core/services/tile_service.dart';
import 'package:mobile/features/offline_map/offline_map_repository.dart';
import 'package:mocktail/mocktail.dart';

class MockTileService extends Mock implements TileService {}

void main() {
  group('offline_map_repository_unit_test', () {
    late OfflineMapRepository offlineMapRepository;
    late MockTileService mockTileService;
    setUp(() {
      mockTileService = MockTileService();
      offlineMapRepository = OfflineMapRepository(mockTileService);
    });

    test('downloadRegion success', () async {
      final bounds = CoordinateBounds(
        southwest: Point(coordinates: Position(0, 0)),
        northeast: Point(coordinates: Position(1, 1)),
        infiniteBounds: true,
      );
      when(() => mockTileService.downloadTiles(any(), any(), any(), any()))
          .thenAnswer((_) async {});

      await offlineMapRepository.downloadRegion(
        regionName: 'test',
        bounds: bounds,
        onProgress: (progress) {},
        onComplete: () {},
        onError: (e) {},
      );
      verify(() => mockTileService.downloadTiles(any(), any(), any(), any()))
          .called(1);
    });
    test('getDownloadedRegions success', () async {
      final region = TileRegion(
        id: '0,0-1,1',
        completedResourceSize: 10,
        completedResourceCount: 10,
        requiredResourceCount: 10,
      );

      when(() => mockTileService.getAllTileRegions())
          .thenAnswer((_) async => [region]);
      final result = await offlineMapRepository.getDownloadedRegions();
      expect(result, [region]);
    });
    test('removeTileRegion success', () async {
      when(() => mockTileService.removeTileRegion(any()))
          .thenAnswer((_) async {});
      await offlineMapRepository.removeTileRegion('test');
      verify(() => mockTileService.removeTileRegion('test')).called(1);
    });
    test('clearOldTiles success', () async {
      when(() => mockTileService.clearOldTiles()).thenAnswer((_) async {});

      await offlineMapRepository.clearOldTiles();
      verify(() => mockTileService.clearOldTiles()).called(1);
    });

    test('getRegionSize', () async {
      final bounds = CoordinateBounds(
        southwest: Point(coordinates: Position(0, 0)),
        northeast: Point(coordinates: Position(1, 1)),
        infiniteBounds: true,
      );
      final region = TileRegion(
        id: '0,0-1,1',
        completedResourceSize: 10,
        completedResourceCount: 10,
        requiredResourceCount: 10,
      );
      when(() => mockTileService.getTileRegion(any()))
          .thenAnswer((_) async => region);
      final size = await offlineMapRepository.getRegionSize(bounds);
      expect(size, '10 B');
    });
    test('getRegionSize null', () async {
      final bounds = CoordinateBounds(
        southwest: Point(coordinates: Position(0, 0)),
        northeast: Point(coordinates: Position(1, 1)),
        infiniteBounds: true,
      );
      when(() => mockTileService.getTileRegion(any()))
          .thenAnswer((_) async => null);
      final size = await offlineMapRepository.getRegionSize(bounds);
      expect(size, '0 B');
    });
  });
}

############## End of /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/test/features/offline_map/offline_map_repository_unit_test.dart ##############

############## Begin of /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/test/features/offline_map/offline_map_viewmodel_unit_test.dart ##############
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:mapbox_maps_flutter/mapbox_maps_flutter.dart';
import 'package:mobile/core/services/map_service.dart';
import 'package:mobile/core/utils/app_constants.dart';
import 'package:mobile/features/offline_map/offline_map_repository.dart';
import 'package:mobile/features/offline_map/offline_map_viewmodel.dart';
import 'package:mocktail/mocktail.dart';

class MockOfflineMapRepository extends Mock implements OfflineMapRepository {}

class MockMapService extends Mock implements MapService {}

class MockMapboxMap extends Mock implements MapboxMap {}

class MockRef<S> extends Mock implements Ref<S> {}

void main() {
  group('offline_map_viewmodel_unit_test', () {
    late OfflineMapViewModel offlineMapViewModel;
    late MockOfflineMapRepository mockOfflineMapRepository;
    late MockMapService mockMapService;
    late MockMapboxMap mockMapboxMap;
    late MockRef<OfflineMapState> mockRef;

    setUp(() {
      mockOfflineMapRepository = MockOfflineMapRepository();
      mockMapService = MockMapService();
      mockMapboxMap = MockMapboxMap();
      mockRef = MockRef<OfflineMapState>();
      offlineMapViewModel = OfflineMapViewModel(
        mockOfflineMapRepository,
        mockRef,
        mockMapService,
      );
      registerFallbackValue(OfflineMapState());
    });
    test('loadRegions success', () async {
      when(() => mockOfflineMapRepository.getDownloadedRegions()).thenAnswer(
        (_) async => [
          TileRegion(
            id: 'test',
            completedResourceSize: 10,
            completedResourceCount: 10,
            requiredResourceCount: 10,
          ),
        ],
      );
      await offlineMapViewModel.loadRegions();
      expect(offlineMapViewModel.state.isLoading, false);
      expect(offlineMapViewModel.state.regions.isNotEmpty, true);
    });
    test('loadRegions failure', () async {
      when(() => mockOfflineMapRepository.getDownloadedRegions())
          .thenThrow(Exception('test'));
      await offlineMapViewModel.loadRegions();

      expect(offlineMapViewModel.state.isLoading, false);
      expect(offlineMapViewModel.state.error, isNotEmpty);
    });
    test('downloadRegion success', () async {
      final bounds = CoordinateBounds(
        southwest: Point(coordinates: Position(0, 0)),
        northeast: Point(coordinates: Position(1, 1)),
        infiniteBounds: true,
      );
      when(() => mockMapService.stylePackProgress)
          .thenReturn(const Stream.empty());
      when(() => mockMapService.tileRegionProgress)
          .thenReturn(const Stream.empty());
      when(
        () => mockOfflineMapRepository.downloadRegion(
          regionName: any(named: 'regionName'),
          bounds: any(named: 'bounds'),
          onProgress: any(named: 'onProgress'),
          onComplete: any(named: 'onComplete'),
          onError: any(named: 'onError'),
          minZoom: any(named: 'minZoom'),
          maxZoom: any(named: 'maxZoom'),
        ),
      ).thenAnswer((_) async {});
      await offlineMapViewModel.downloadRegion(
        bounds: bounds,
        minZoom: 1,
        maxZoom: 5,
        onProgress: (progress) {},
        onComplete: () {},
      );
      expect(
        offlineMapViewModel.state.downloadStatus,
        DownloadStatus.completed,
      );
    });
    test('downloadRegion failure', () async {
      final bounds = CoordinateBounds(
        southwest: Point(coordinates: Position(0, 0)),
        northeast: Point(coordinates: Position(1, 1)),
        infiniteBounds: true,
      );

      when(() => mockMapService.stylePackProgress)
          .thenReturn(const Stream.empty());
      when(() => mockMapService.tileRegionProgress)
          .thenReturn(const Stream.empty());
      when(
        () => mockOfflineMapRepository.downloadRegion(
          regionName: any(named: 'regionName'),
          bounds: any(named: 'bounds'),
          onProgress: any(named: 'onProgress'),
          onComplete: any(named: 'onComplete'),
          onError: any(named: 'onError'),
          minZoom: any(named: 'minZoom'),
          maxZoom: any(named: 'maxZoom'),
        ),
      ).thenThrow(Exception('test'));

      await offlineMapViewModel.downloadRegion(
        bounds: bounds,
        minZoom: 1,
        maxZoom: 5,
        onProgress: (progress) {},
        onComplete: () {},
      );
      expect(offlineMapViewModel.state.downloadStatus, DownloadStatus.idle);
      expect(offlineMapViewModel.state.error, isNotEmpty);
    });
    test('deleteRegion success', () async {
      when(() => mockOfflineMapRepository.removeTileRegion(any()))
          .thenAnswer((_) async {});
      when(() => mockOfflineMapRepository.getDownloadedRegions())
          .thenAnswer((_) async => []);
      await offlineMapViewModel.deleteRegion('test');
      expect(offlineMapViewModel.state.isLoading, false);
      verify(() => mockOfflineMapRepository.removeTileRegion(any())).called(1);
    });
    test('deleteRegion failure', () async {
      when(() => mockOfflineMapRepository.removeTileRegion(any()))
          .thenThrow(Exception('test'));
      await offlineMapViewModel.deleteRegion('test');
      expect(offlineMapViewModel.state.isLoading, false);
      expect(offlineMapViewModel.state.error, isNotEmpty);
    });
    test('moveToCurrentLocation success', () async {
      when(() => mockMapboxMap.flyTo(any(), any())).thenAnswer((_) async {});
      await offlineMapViewModel.moveToCurrentLocation(mockMapboxMap);
      expect(offlineMapViewModel.state.isLocationLoading, false);
    });
    test('clearAllTiles success', () async {
      when(() => mockOfflineMapRepository.clearOldTiles())
          .thenAnswer((_) async {});

      await offlineMapViewModel.clearAllTiles();
      verify(() => mockOfflineMapRepository.clearOldTiles()).called(1);
    });
    test('getRegionSize success', () async {
      final bounds = CoordinateBounds(
        southwest: Point(coordinates: Position(0, 0)),
        northeast: Point(coordinates: Position(1, 1)),
        infiniteBounds: true,
      );
      when(() => mockOfflineMapRepository.getRegionSize(any()))
          .thenAnswer((_) async => '10 B');
      final result = await offlineMapViewModel.getRegionSize(bounds);
      expect(result, '10 B');
    });
    test('getRegionSize failure', () async {
      final bounds = CoordinateBounds(
        southwest: Point(coordinates: Position(0, 0)),
        northeast: Point(coordinates: Position(1, 1)),
        infiniteBounds: true,
      );
      when(() => mockOfflineMapRepository.getRegionSize(any()))
          .thenThrow(Exception('test'));
      expect(
        () async => offlineMapViewModel.getRegionSize(bounds),
        throwsA(isA<OfflineMapViewModelException>()),
      );
    });
  });
}

############## End of /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/test/features/offline_map/offline_map_viewmodel_unit_test.dart ##############

############## Begin of /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/test/features/offline_map/offline_map_screen_widget_test.dart ##############
// test/features/offline_map/offline_map_screen_widget_test.dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:mobile/features/offline_map/offline_map_screen.dart';
import 'package:mocktail/mocktail.dart';

class MockNavigatorObserver extends Mock implements NavigatorObserver {}

void main() {
  group('offline_map_screen_widget_test', () {
    testWidgets('offline map screen renders', (WidgetTester tester) async {
      final mockObserver = MockNavigatorObserver();
      await tester.pumpWidget(
        ProviderScope(
          child: MaterialApp(
            home: const OfflineMapScreen(),
            navigatorObservers: [mockObserver],
          ),
        ),
      );
      expect(find.byType(OfflineMapScreen), findsOneWidget);
    });
    // TODO: Add test for download button
    //TODO: Add test for map button
    // testWidgets('show download dialog', (WidgetTester tester) async {
    //    final mockObserver = MockNavigatorObserver();
    //     await tester.pumpWidget(
    //       ProviderScope(
    //         child: MaterialApp(
    //           home: const OfflineMapScreen(),
    //           navigatorObservers: [mockObserver],
    //         ),
    //       ),
    //     );
    //       await tester.tap(find.byIcon(Icons.download));

    //       expect(find.byType(AlertDialog), findsOneWidget);
    // });
    // testWidgets('show regions dialog', (WidgetTester tester) async {
    //  final mockObserver = MockNavigatorObserver();
    //   await tester.pumpWidget(
    //     ProviderScope(
    //       child: MaterialApp(
    //         home: const OfflineMapScreen(),
    //         navigatorObservers: [mockObserver],
    //       ),
    //     ),
    //   );
    //     await tester.tap(find.byIcon(Icons.map));
    //      expect(find.byType(AlertDialog), findsOneWidget);
    // });
  });
}

############## End of /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/test/features/offline_map/offline_map_screen_widget_test.dart ##############

############## Directory: /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/test/features/offline_map ##############

############## Begin of /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/test/features/map/map_screen_widget_test.dart ##############
// test/features/map/map_screen_widget_test.dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:mobile/features/map/map_screen.dart';
import 'package:mocktail/mocktail.dart';

class MockNavigatorObserver extends Mock implements NavigatorObserver {}

void main() {
  group('map_screen_widget_test', () {
    testWidgets('map screen renders', (WidgetTester tester) async {
      final mockObserver = MockNavigatorObserver();
      await tester.pumpWidget(
        ProviderScope(
          child: MaterialApp(
            home: const MapScreen(),
            navigatorObservers: [mockObserver],
          ),
        ),
      );
      expect(find.byType(MapScreen), findsOneWidget);
    });
    //  testWidgets('refresh button works', (WidgetTester tester) async {
    //       final mockObserver = MockNavigatorObserver();
    //     await tester.pumpWidget(
    //       ProviderScope(
    //         child: MaterialApp(
    //           home: const MapScreen(),
    //           navigatorObservers: [mockObserver],
    //         ),
    //       ),
    //     );

    //    await tester.tap(find.byIcon(Icons.refresh));
    //   //  TODO: Add assertion for the refresh action

    //   });
  });
}

############## End of /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/test/features/map/map_screen_widget_test.dart ##############

############## Begin of /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/test/features/map/map_viewmodel_unit_test.dart ##############
// test/features/map/map_viewmodel_unit_test.dart
import 'package:dartz/dartz.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:mapbox_maps_flutter/mapbox_maps_flutter.dart';
import 'package:mobile/core/services/map_service.dart';
import 'package:mobile/features/map/map_repository.dart';
import 'package:mobile/features/map/map_viewmodel.dart';
import 'package:mobile/shared/models/map_marker.dart' as map_marker;
import 'package:mocktail/mocktail.dart';

class MockMapRepository extends Mock implements MapRepository {}

class MockMapService extends Mock implements MapService {}

class MockMapboxMap extends Mock implements MapboxMap {}

class MockRef<S> extends Mock implements Ref<S> {}

void main() {
  group('map_viewmodel_unit_test', () {
    late MapViewModel mapViewModel;
    late MockMapRepository mockMapRepository;
    late MockMapService mockMapService;
    late MockMapboxMap mockMapboxMap;
    late MockRef<MapState> mockRef;

    setUp(() {
      mockMapRepository = MockMapRepository();
      mockMapService = MockMapService();
      mockMapboxMap = MockMapboxMap();
      mockRef = MockRef<MapState>();
      mapViewModel = MapViewModel(mockMapRepository, mockMapService, mockRef);
      registerFallbackValue(MapState());

      mapViewModel.setMap(mockMapboxMap);
    });
    test('loadMarkers success', () async {
      when(() => mockMapRepository.getMarkers()).thenAnswer(
        (_) async => Right([
          map_marker.MapMarker(
            id: 'test',
            title: 'test',
            description: 'test',
            geometry: map_marker.Geometry(
              type: map_marker.GeometryType.point,
              coordinates: [0.0, 0.0],
            ),
          ),
        ]),
      );
      await mapViewModel.loadMarkers();
      expect(mapViewModel.state.isLoading, false);
      expect(mapViewModel.state.markers.isNotEmpty, true);
    });
    test('loadMarkers failure', () async {
      when(() => mockMapRepository.getMarkers()).thenAnswer(
        (_) async => Left(MapRepositoryException('test error', 'test')),
      );

      await mapViewModel.loadMarkers();
      expect(mapViewModel.state.isLoading, false);
      expect(mapViewModel.state.error, isNotEmpty);
    });
    test('clearMarkers', () async {
      mapViewModel.clearMarkers();
      expect(mapViewModel.state.markers, isEmpty);
    });
    test('moveToFirstMarker success', () async {
      final markers = [
        map_marker.MapMarker(
          id: 'test',
          title: 'test',
          description: 'test',
          geometry: map_marker.Geometry(
            type: map_marker.GeometryType.point,
            coordinates: [1.0, 1.0],
          ),
        ),
      ];
      when(() => mockMapRepository.getMarkers())
          .thenAnswer((_) async => Right(markers));
      when(() => mockMapboxMap.flyTo(any(), any())).thenAnswer((_) async {});
      await mapViewModel.loadMarkers();
      await mapViewModel.moveToFirstMarker();
      verify(() => mockMapboxMap.flyTo(any(), any())).called(1);
    });
    test('moveToFirstMarker no markers', () async {
      when(() => mockMapRepository.getMarkers())
          .thenAnswer((_) async => const Right([]));
      await mapViewModel.loadMarkers();
      await mapViewModel.moveToFirstMarker();
      verifyNever(() => mockMapboxMap.flyTo(any(), any()));
    });
    test('moveToFirstMarker invalid geometry', () async {
      final markers = [
        map_marker.MapMarker(
          id: 'test',
          title: 'test',
          description: 'test',
          geometry: map_marker.Geometry(
            type: map_marker.GeometryType.lineString,
            coordinates: [1.0, 1.0],
          ),
        ),
      ];
      when(() => mockMapRepository.getMarkers())
          .thenAnswer((_) async => Right(markers));
      await mapViewModel.loadMarkers();
      await mapViewModel.moveToFirstMarker();
      verifyNever(() => mockMapboxMap.flyTo(any(), any()));
    });
  });
}

############## End of /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/test/features/map/map_viewmodel_unit_test.dart ##############

############## Begin of /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/test/features/map/map_repository_unit_test.dart ##############
// test/features/map/map_repository_unit_test.dart
import 'package:dio/dio.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:mobile/core/services/network_service.dart';
import 'package:mobile/core/services/storage_service.dart';
import 'package:mobile/features/map/map_repository.dart';
import 'package:mobile/shared/models/map_marker.dart';
import 'package:mocktail/mocktail.dart';

class MockNetworkService extends Mock implements NetworkService {}

class MockStorage extends Mock implements Storage {}

void main() {
  group('map_repository_unit_test', () {
    late MapRepository mapRepository;
    late MockNetworkService mockNetworkService;
    late MockStorage mockStorage;
    setUp(() {
      mockNetworkService = MockNetworkService();
      mockStorage = MockStorage();
      mapRepository = MapRepository(mockNetworkService, mockStorage);
    });
    test('getMarkers success from api', () async {
      when(() => mockNetworkService.get(any())).thenAnswer(
        (_) async => Response(
          requestOptions: RequestOptions(),
          data: {
            'results': [
              {
                'id': 'test',
                'name': 'test',
                'description': 'test',
                'geometry': {
                  'type': 'Point',
                  'coordinates': [0.0, 0.0],
                },
              }
            ],
          },
          statusCode: 200,
        ),
      );
      when(() => mockStorage.getInt(any())).thenAnswer((_) async => null);
      when(() => mockStorage.saveMarkers(any())).thenAnswer((_) async {});
      final result = await mapRepository.getMarkers();
      expect(result.isRight(), true);
    });

    test('getMarkers success from cache', () async {
      final markers = [
        MapMarker(
          id: 'test',
          title: 'test',
          description: 'test',
          geometry: Geometry(type: GeometryType.point, coordinates: [0.0, 0.0]),
        ),
      ];
      when(() => mockStorage.getInt(any()))
          .thenAnswer((_) async => DateTime.now().millisecondsSinceEpoch);
      when(() => mockStorage.getMarkers()).thenAnswer((_) async => markers);

      final result = await mapRepository.getMarkers();
      expect(result.isRight(), true);
      result.fold((l) => null, (r) => expect(r, markers));
    });
    test('getMarkers failure from api, success from cache', () async {
      when(() => mockNetworkService.get(any())).thenThrow(
        DioException(
          requestOptions: RequestOptions(),
          type: DioExceptionType.badResponse,
        ),
      );

      final markers = [
        MapMarker(
          id: 'test',
          title: 'test',
          description: 'test',
          geometry: Geometry(type: GeometryType.point, coordinates: [0.0, 0.0]),
        ),
      ];
      when(() => mockStorage.getMarkers()).thenAnswer((_) async => markers);
      final result = await mapRepository.getMarkers();
      expect(result.isRight(), true);
      result.fold((l) => null, (r) => expect(r, markers));
    });
    test('getMarkers failure', () async {
      when(() => mockNetworkService.get(any())).thenThrow(
        DioException(
          requestOptions: RequestOptions(),
          type: DioExceptionType.badResponse,
        ),
      );
      when(() => mockStorage.getMarkers()).thenAnswer((_) async => []);

      final result = await mapRepository.getMarkers();

      expect(result.isLeft(), true);
    });
    test('updateMarker success', () async {
      final marker = MapMarker(
        id: 'test',
        title: 'test',
        description: 'test',
        geometry: Geometry(type: GeometryType.point, coordinates: [0.0, 0.0]),
      );
      when(() => mockNetworkService.put(any(), any())).thenAnswer(
        (_) async =>
            Response(requestOptions: RequestOptions(), statusCode: 200),
      );
      when(() => mockStorage.getMarkers()).thenAnswer((_) async => [marker]);
      when(() => mockStorage.saveMarkers(any())).thenAnswer((_) async {});

      await mapRepository.updateMarker(marker);
      verify(() => mockNetworkService.put(any(), any())).called(1);
      verify(() => mockStorage.saveMarkers(any())).called(1);
    });
    test('updateMarker failure', () async {
      final marker = MapMarker(
        id: 'test',
        title: 'test',
        description: 'test',
        geometry: Geometry(type: GeometryType.point, coordinates: [0.0, 0.0]),
      );

      when(() => mockNetworkService.put(any(), any())).thenThrow(
        DioException(
          requestOptions: RequestOptions(),
          type: DioExceptionType.badResponse,
        ),
      );
      expect(
        () async => mapRepository.updateMarker(marker),
        throwsA(isA<MapRepositoryException>()),
      );
    });
  });
}

############## End of /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/test/features/map/map_repository_unit_test.dart ##############

############## Directory: /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/test/features/map ##############

############## Directory: /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/test/shared ##############

############## Begin of /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/test/shared/widgets/offline_banner_unit_test.dart ##############
// test/shared/widgets/offline_banner_unit_test.dart
import 'package:flutter/material.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:mobile/shared/widgets/offline_banner.dart';

void main() {
  group('offline_banner_unit_test', () {
    testWidgets('offline banner renders offline', (WidgetTester tester) async {
      await tester.pumpWidget(
        const MaterialApp(
          home: OfflineBanner(isOffline: true),
        ),
      );
      expect(find.text('Offline Mode'), findsOneWidget);
      expect(find.byType(Container), findsOneWidget);
    });
    testWidgets('offline banner does not render when not offline',
        (WidgetTester tester) async {
      await tester.pumpWidget(
        const MaterialApp(
          home: OfflineBanner(),
        ),
      );
      expect(find.byType(Container), findsNothing);
    });
  });
}

############## End of /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/test/shared/widgets/offline_banner_unit_test.dart ##############

############## Begin of /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/test/shared/widgets/theme_picker_widget_test.dart ##############
// test/shared/widgets/theme_picker_widget_test.dart
import 'package:flutter/material.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:mobile/shared/widgets/theme_picker.dart';

void main() {
  group('theme_picker_widget_test', () {
    testWidgets('theme picker renders', (WidgetTester tester) async {
      await tester.pumpWidget(
        MaterialApp(
          home: ThemePicker(onThemeChanged: (_) {}),
        ),
      );
      expect(find.text('Light Theme'), findsOneWidget);
      expect(find.text('Dark Theme'), findsOneWidget);
      expect(find.byType(Radio<ThemeMode>), findsNWidgets(2));
    });
    testWidgets('theme change works', (WidgetTester tester) async {
      ThemeMode? selectedTheme;

      await tester.pumpWidget(
        MaterialApp(
          home: ThemePicker(
            onThemeChanged: (theme) {
              selectedTheme = theme;
            },
          ),
        ),
      );
      await tester.tap(find.text('Dark Theme'));

      expect(selectedTheme, ThemeMode.dark);
    });
  });
}

############## End of /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/test/shared/widgets/theme_picker_widget_test.dart ##############

############## Begin of /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/test/shared/widgets/map_controls_unit_test.dart ##############
// test/shared/widgets/map_controls_unit_test.dart
import 'package:flutter/material.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:mobile/shared/widgets/map_controls.dart';

void main() {
  group('map_controls_unit_test', () {
    testWidgets('map controls render', (WidgetTester tester) async {
      await tester.pumpWidget(
        MaterialApp(
          home: MapControls(
            onZoomIn: () {},
            onZoomOut: () {},
            onMoveToCurrentLocation: () {},
          ),
        ),
      );
      expect(find.byIcon(Icons.add), findsOneWidget);
      expect(find.byIcon(Icons.remove), findsOneWidget);
      expect(find.byIcon(Icons.my_location), findsOneWidget);
    });
    testWidgets('map controls tap', (WidgetTester tester) async {
      var zoomIn = false;
      var zoomOut = false;
      var location = false;
      await tester.pumpWidget(
        MaterialApp(
          home: MapControls(
            onZoomIn: () {
              zoomIn = true;
            },
            onZoomOut: () {
              zoomOut = true;
            },
            onMoveToCurrentLocation: () {
              location = true;
            },
          ),
        ),
      );

      await tester.tap(find.byIcon(Icons.add));
      expect(zoomIn, true);

      await tester.tap(find.byIcon(Icons.remove));
      expect(zoomOut, true);

      await tester.tap(find.byIcon(Icons.my_location));
      expect(location, true);
    });
  });
}

############## End of /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/test/shared/widgets/map_controls_unit_test.dart ##############

############## Begin of /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/test/shared/widgets/loading_overlay_widget_test.dart ##############
// test/shared/widgets/loading_overlay_widget_test.dart
import 'package:flutter/material.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:mobile/shared/widgets/loading_overlay.dart';

void main() {
  group('loading_overlay_widget_test', () {
    testWidgets('loading overlay renders', (WidgetTester tester) async {
      await tester.pumpWidget(
        const MaterialApp(
          home: LoadingOverlay(),
        ),
      );
      expect(find.byType(CircularProgressIndicator), findsOneWidget);
    });
    testWidgets('loading overlay with message', (WidgetTester tester) async {
      await tester.pumpWidget(
        const MaterialApp(
          home: LoadingOverlay(message: 'test message'),
        ),
      );
      expect(find.text('test message'), findsOneWidget);
    });
    testWidgets('loading overlay with cancel', (WidgetTester tester) async {
      var isCanceled = false;
      await tester.pumpWidget(
        MaterialApp(
          home: LoadingOverlay(
            onCancel: () {
              isCanceled = true;
            },
          ),
        ),
      );
      await tester.tap(find.text('Cancel'));
      expect(isCanceled, true);
    });
  });
}

############## End of /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/test/shared/widgets/loading_overlay_widget_test.dart ##############

############## Begin of /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/test/shared/widgets/map_widget_unit_test.dart ##############
// test/shared/widgets/map_widget_unit_test.dart
import 'package:flutter/material.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:mapbox_maps_flutter/mapbox_maps_flutter.dart';
import 'package:mobile/shared/widgets/map_widget.dart';
import 'package:mocktail/mocktail.dart';

class MockMapboxMap extends Mock implements MapboxMap {}

void main() {
  group('map_widget_unit_test', () {
    testWidgets('custom map widget renders', (WidgetTester tester) async {
      final mockMapboxMap = MockMapboxMap();
      await tester.pumpWidget(
        MaterialApp(
          home: CustomMapWidget(
            cameraOptions: CameraOptions(),
            onMapCreated: (map) {
              mockMapboxMap;
            },
            styleUri: 'test',
          ),
        ),
      );
      expect(find.byType(MapWidget), findsOneWidget);
    });
  });
}

############## End of /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/test/shared/widgets/map_widget_unit_test.dart ##############

############## Begin of /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/test/shared/widgets/custom_error_widget_test.dart ##############
// test/shared/widgets/custom_error_widget_test.dart
import 'package:flutter/material.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:mobile/shared/widgets/custom_error_widget.dart';

void main() {
  group('custom_error_widget_test', () {
    testWidgets('custom error widget renders', (WidgetTester tester) async {
      await tester.pumpWidget(
        const MaterialApp(
          home: CustomErrorWidget(error: 'test error'),
        ),
      );
      expect(find.text('test error'), findsOneWidget);
      expect(find.text('Close'), findsOneWidget);
    });
    testWidgets('custom error widget onClose works',
        (WidgetTester tester) async {
      var isClosed = false;
      await tester.pumpWidget(
        MaterialApp(
          home: CustomErrorWidget(
            error: 'test error',
            onClose: () {
              isClosed = true;
            },
          ),
        ),
      );
      await tester.tap(find.text('Close'));
      expect(isClosed, true);
    });
  });
}

############## End of /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/test/shared/widgets/custom_error_widget_test.dart ##############

############## Begin of /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/test/shared/widgets/region_item_widget_test.dart ##############
// test/features/settings/widgets/region_item_widget_test.dart
import 'package:flutter/material.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:mapbox_maps_flutter/mapbox_maps_flutter.dart';
import 'package:mobile/shared/widgets/region_item.dart';

void main() {
  group('region_item_widget_test', () {
    testWidgets('region item renders', (WidgetTester tester) async {
      final region = TileRegion(
        id: 'test',
        completedResourceSize: 10,
        completedResourceCount: 10,
        requiredResourceCount: 10,
      );
      await tester.pumpWidget(
        MaterialApp(
          home: RegionItem(region: region, deleteRegion: (_) {}),
        ),
      );
      expect(find.text('test'), findsOneWidget);
      expect(find.byIcon(Icons.delete), findsOneWidget);
    });
    testWidgets('delete region works', (WidgetTester tester) async {
      final region = TileRegion(
        id: 'test',
        completedResourceSize: 10,
        completedResourceCount: 10,
        requiredResourceCount: 10,
      );

      var isDeleted = false;
      await tester.pumpWidget(
        MaterialApp(
          home: RegionItem(
            region: region,
            deleteRegion: (_) {
              isDeleted = true;
            },
          ),
        ),
      );
      await tester.tap(find.byIcon(Icons.delete));
      expect(isDeleted, true);
    });
  });
}

############## End of /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/test/shared/widgets/region_item_widget_test.dart ##############

############## Directory: /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/test/shared/widgets ##############

############## Begin of /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/test/performance/memory_leak_performance_test.dart ##############
// test/performance/memory_leak_performance_test.dart
import 'package:flutter_test/flutter_test.dart';

void main() {
  group('memory_leak_performance_test', () {
    test('initial test', () {
      // TODO: Implement test.
      // For memory leak tests, consider using a memory profiler
      // which need additional setup and are not included here.
    });
  });
}

############## End of /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/test/performance/memory_leak_performance_test.dart ##############

############## Begin of /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/test/performance/load_time_performance_test.dart ##############
// test/performance/load_time_performance_test.dart
import 'package:flutter_test/flutter_test.dart';

void main() {
  group('load_time_performance_test', () {
    test('initial test', () {
      // TODO: Implement test.
      // For load time tests, consider using a performance testing tools
      // which need additional setup and are not included here.
      //  Performance test code goes here.
      // Typically involves timing the loading of certain
      // parts of the app.
    });
  });
}

############## End of /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/test/performance/load_time_performance_test.dart ##############

############## Begin of /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/test/performance/frame_rate_performance_test.dart ##############
// test/performance/frame_rate_performance_test.dart
import 'package:flutter_test/flutter_test.dart';

void main() {
  group('frame_rate_performance_test', () {
    test('initial test', () {
      // TODO: Implement test.
      // For frame rate tests, consider using a performance testing tools
      // which need additional setup and are not included here.
      // Performance test code goes here.
      // Typically involves running the app for a period
      // and checking for frame drops.
    });
  });
}

############## End of /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/test/performance/frame_rate_performance_test.dart ##############

############## Directory: /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/test/performance ##############

############## Begin of /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/test/e2e/app_e2e_test.dart ##############
// test/e2e/app_e2e_test.dart
import 'package:flutter_test/flutter_test.dart';

void main() {
  group('app_e2e_test', () {
    test('initial test', () {
      // TODO: Implement test.
      // For e2e tests, consider using flutter_driver or integration_test
      // which need additional setup and are not included here.
    });
  });
}

############## End of /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/test/e2e/app_e2e_test.dart ##############

############## Directory: /Users/edsteine/Documents/Projects/PortfolioProjects/wproject2/test/e2e ##############

